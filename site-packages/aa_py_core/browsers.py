import os
import subprocess
from pathlib import Path
from typing import Iterable, Optional

localappdata = os.getenv('localappdata')
windir = os.getenv('windir')

chrome_paths = [
    # Windows
    Path(r"C:\Program Files\Google\Chrome\Application\chrome.exe"),
    Path(r"C:\Program Files (x86)\Google\Chrome\Application\chrome.exe"),
    Path(rf"{localappdata}/Google/Chrome/Application/chrome.exe"),

    # Linux
    Path('/usr/bin/google-chrome'),
]

firefox_paths = [
    # Windows
    Path(r"C:/Program Files/Mozilla Firefox/firefox.exe"),
    Path(r"C:/Program Files (x86)/Mozilla Firefox/firefox.exe"),
    Path(rf"{localappdata}/Mozilla Firefox/firefox.exe"),

    # Linux
    Path('/usr/bin/firefox'),
]


def _find_existing_path(haystack: Iterable[Path]) -> Optional[Path]:
    for p in haystack:
        if p.exists():
            return p
    return None


def has_edge() -> bool:
    # This is the path of the Edge executable, but it cannot be launched directly like other browsers.
    p = Path(rf"{windir}\SystemApps\Microsoft.MicrosoftEdge_8wekyb3d8bbwe\MicrosoftEdge.exe")
    return p.is_file()


def get_cmd_line(url: str) -> str:
    # Try chrome, then firefox.
    path = _find_existing_path(chrome_paths) or _find_existing_path(firefox_paths)
    if path:
        return f'"{str(path)}" "{url}"'

    # Try edge.
    if has_edge():
        return 'explorer microsoft-edge:"{url}"'


def open_in_modern_browser(url: str, wait=False) -> None:
    """
    Find a modern browser and open the given URL there.

    :param url:
    :param wait: Whether to wait for the browser process to close before returning.
    If False, the browser process may continue to live after the python process has executed.

    :return:
    """
    p = subprocess.Popen(get_cmd_line(url), close_fds=True)
    if wait:
        p.wait()
