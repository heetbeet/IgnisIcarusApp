import contextlib
import os
import tempfile
import zipfile
from pathlib import Path
from typing import Union, Tuple, BinaryIO, Generator


def delete_file_if_exists(path):
    with contextlib.suppress(FileNotFoundError):
        os.remove(path)


@contextlib.contextmanager
def working_directory(path: Union[str, Path]):
    """
    On entry, change directory to specified path.
    On exit, change directory to original.

    >>> import tempfile
    >>> tmpdir = tempfile.mktemp()
    >>> os.makedirs(tmpdir)

    >>> working_dir = os.getcwd()

    >>> with working_directory(tmpdir):
    ...     os.getcwd() == working_dir
    False

    >>> with working_directory(tmpdir):
    ...     os.getcwd() == tmpdir
    True

    >>> os.getcwd() == working_dir
    True

    >>> import shutil
    >>> shutil.rmtree(tmpdir)
    """
    this_dir = os.getcwd()
    os.chdir(path)
    try:
        yield
    finally:
        os.chdir(this_dir)


def looks_like_zip_file(path: Union[Path, str]) -> bool:
    """
    Check if the given path looks like a path to a zip file.
    """
    # This is quite a primitive approach. Here may be room for improvement.
    return Path(path).name.lower().endswith('.zip')


@contextlib.contextmanager
def open_maybe_zipped(path: Union[Path, str], mode: str) -> Tuple[BinaryIO, float]:
    """
    Context manager to open a file, possibly zipped.

    If it's a zip file containing only one file, open that file. Also yield the compression ratio.
    If it's not a zip file, open that file. Compression ratio will be 1.
    Always open as binary.
    If the zip file contains more than one file, throw an error.

    :param path: The path of the file or zip file to open.
    :param mode: The mode to pass to the "open" function. Only allow "r" and "w".
    :return:
        A tuple containing the file pointer and a compression ratio.
    """
    path = Path(path)

    if mode not in {"r", "w"}:
        raise ValueError('open_maybe_zipped() requires mode "r" or "w"')

    # If it's a zip file, read the file inside of it.
    if looks_like_zip_file(path):
        with zipfile.ZipFile(path) as z:
            if len(z.namelist()) != 1:
                raise ValueError("open_maybe_zipped() only supports single-file zip files")

            ratio = z.infolist()[0].file_size / z.infolist()[0].compress_size
            fp = z.open(z.namelist()[0], mode)
            try:
                yield fp, ratio
            finally:
                fp.close()
    else:
        fp = open(path, f"{mode}b")
        try:
            yield fp, 1
        finally:
            fp.close()


@contextlib.contextmanager
def temporarily_extract_maybe_zipped_directory(path: Path) -> Generator[Path, None, None]:
    """
    If the given path refers to a zip file, extract it to a temporary directory, and yield the path to that directory.
    The directory will be deleted when the context manager closes. If the path does not refer to a zip file, it is
    yielded verbatim, and it will not be deleted afterwards.
    """
    path = path.resolve()

    if not looks_like_zip_file(path):
        yield path
        return

    with temporarily_extract_zip_file(path) as tmp_dir:
        yield tmp_dir


@contextlib.contextmanager
def temporarily_extract_zip_file(zip_file_path: Path) -> Generator[Path, None, None]:
    with tempfile.TemporaryDirectory() as tmp_dir:
        with zipfile.ZipFile(zip_file_path) as z:
            z.extractall(tmp_dir)

        yield Path(tmp_dir)
