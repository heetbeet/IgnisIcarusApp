"""
Utilities for working with files that are locked by other processes.
(This is not where we implement our own file locking mechanisms.)
"""

import os
import shutil
from collections import defaultdict
from contextlib import suppress
from pathlib import Path
from typing import Dict, List, Union

import psutil
from aa_py_core.processes import kill_pid, PID


def get_file_locks() -> Dict[str, List[PID]]:
    """
    A dictionary of all the filepaths that are locked, and the corresponding pids that are locking them.
    """
    d = defaultdict(list)
    for proc in psutil.process_iter():
        opened_files = []
        memory_files = []

        with suppress(psutil.AccessDenied, psutil.NoSuchProcess):
            opened_files = [str(i.path).lower() for i in proc.open_files() if os.path.exists(i.path)]

        with suppress(psutil.AccessDenied, psutil.NoSuchProcess):
            memory_files = [str(i.path).lower() for i in proc.memory_maps() if os.path.exists(i.path)]

        pid = PID(pid=proc.pid, name=proc.name())
        for file in opened_files + memory_files:
            d[file].append(pid)

    return {**d}


def get_locked_paths(path) -> Dict[str, List[PID]]:
    """
    For a given path, find all pids locking that path or any sub-path.
    """
    all_locks = get_file_locks()
    locked_paths = {}

    for root, dir_names, file_names in os.walk(path):
        for file_name in file_names:
            file_path = Path(root, file_name).resolve()
            if (ist := str(file_path).lower()) in all_locks:
                locked_paths[ist] = all_locks[ist]

    return locked_paths


def rm_and_kill(path: Union[str, Path], missing_ok: bool = False):
    """
    Try to delete a directory path or a filepath by focefully removing any locks on the file using `os.kill`.
    """
    path = Path(path).resolve()

    if path.is_dir():
        rm_and_kill_dir(path)

    elif path.is_file():
        rm_and_kill_file(path)

    elif not missing_ok:
        raise FileNotFoundError(f"The system cannot find: {path}")


def rm_and_kill_file(path):
    try:
        os.remove(path)
    except PermissionError:
        s = os.path.abspath(path).lower()
        locks = get_file_locks()
        for pid in locks[s]:
            kill_pid(pid.pid, missing_ok=True)

        os.remove(path)


def rm_and_kill_dir(path):
    shutil.rmtree(path, ignore_errors=True)

    if path.exists():
        locks = get_file_locks()
        for root, dir_names, file_names in os.walk(path):
            for file_name in file_names:
                file_path = Path(root, file_name)
                s = os.path.abspath(file_path).lower()
                if s in locks:
                    for pid in locks[s]:
                        kill_pid(pid.pid, missing_ok=True)

    shutil.rmtree(path, ignore_errors=True)

    # In order to see what error is stalling the deletion:
    if path.exists():
        shutil.rmtree(path)
