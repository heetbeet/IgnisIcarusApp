import contextlib
import io
from pathlib import Path
from typing import Iterable, Union, List, Dict

import sys
from locate import this_dir

test_dir = this_dir().parent.joinpath('test')


def find_ci_duplicate(it: Iterable[str]) -> Union[bool, str]:
    """
    Iterate over strings, checking for case-insensitive duplicates.

    :param it: An iterable of strings.

    :return:
        The first duplicate string, if found.
        False if the iteration completed without finding a duplicate.

    >>> find_ci_duplicate(["a", "b", "C", "D"])
    False

    >>> find_ci_duplicate(["a", "b", "A", "D"])
    'A'

    >>> find_ci_duplicate(["a", "B", "c", "b"])
    'b'
    """
    seen = set()
    for msg in it:
        msg_lower = msg.lower()
        if msg_lower in seen:
            return msg
        else:
            seen.add(msg_lower)

    return False


def all_none(it: Iterable):
    for item in it:
        if item is not None:
            return False
    return True


def cluster_sequential(x: List[int]) -> Dict[int, int]:
    """
    For a given sequence like [1,2,3,10,11,12,25,26,50], find all the sequentual sections like 1,2,3 and
    10,11,12 and 25,26 and 50. Return their first instance and length as a dictionary.

    >>> cluster_sequential([1,2,3,5,6,7,9,10,11])
    {1: 3, 5: 3, 9: 3}
    """
    if not x:
        return {}

    # Initiate buckets
    buckets = {x[0]: 1}
    for i in range(1, len(x)):
        if x[i - 1] != x[i] - 1:
            buckets[x[i]] = 1

    # Fill buckets with sequential sections
    i = -1
    while i < len(x) - 1:
        i += 1

        if x[i] in buckets:
            ii = i + 1
            for ii in range(ii, len(x)):
                if x[ii] - 1 == x[ii - 1]:
                    buckets[x[i]] += 1
                else:
                    break

            i = ii - 1

    return buckets


@contextlib.contextmanager
def no_stdout():
    """
    Contextmanager to supress printing to stdout in case of normal execution. In case of an error though, catch it and
    print the supressed output before raising the error.

    Print to stdout without supression
    >>> print('hello')
    hello

    Can't print to stdout because of supression
    >>> with no_stdout():
    ...     print('hello')

    Will print to stdout in the case of an error.
    >>> try:
    ...     with no_stdout():
    ...         print("Starting...")
    ...         raise RuntimeError("Oops!")
    ... except RuntimeError as e:
    ...     print(e)
    Starting...
    <BLANKLINE>
    Oops!
    """

    saved_stdout = sys.stdout
    sys.stdout = io.StringIO()
    try:
        yield
    except Exception:
        saved_output = sys.stdout
        sys.stdout = saved_stdout
        print(saved_output.getvalue())
        raise
    sys.stdout = saved_stdout


def try_paths(paths: Iterable[Path]) -> Path:
    """
    Return the first existing path in the given iterable of paths.

    >>> from tempfile import TemporaryDirectory

    >>> with TemporaryDirectory() as tmp_dir:
    ...     with Path(tmp_dir, 'foo').open('w') as f:
    ...         _ = f.write("bar")
    ...     try_paths([
    ...         Path(tmp_dir, 'moo'), # Does not exist
    ...         Path(tmp_dir, 'bar'), # Does not exist
    ...         Path(tmp_dir, 'foo'), # Exists
    ...         Path(tmp_dir, 'goo'), # Does not exist
    ...     ]).relative_to(tmp_dir).as_posix()
    'foo'

    >>> with TemporaryDirectory() as tmp_dir:
    ...     try_paths([
    ...         Path(tmp_dir, 'moo'), # Does not exist
    ...         Path(tmp_dir, 'bar'), # Does not exist
    ...         Path(tmp_dir, 'foo'), # Does not exist
    ...         Path(tmp_dir, 'goo'), # Does not exist
    ...     ]).relative_to(tmp_dir).as_posix()
    Traceback (most recent call last):
    ...
    FileNotFoundError
    """
    for p in paths:
        if p.exists():
            return p

    raise FileNotFoundError
