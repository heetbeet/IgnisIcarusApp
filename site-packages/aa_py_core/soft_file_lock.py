"""
Utilities for soft-locking files.

Soft-locking is locking by proxy, i.e. creating a lock file next to the locked file, rather than using the OS's locking
mechanism. It only works if all processes agree to respect the lock file.
"""
from contextlib import contextmanager
from pathlib import Path
from types import SimpleNamespace
from typing import Union, Generator

from filelock import SoftFileLock


def get_lock_file_path(file_path: Path) -> Path:
    r"""
    This function defines a global standard for how we name our lock files. It's good to be consistent.

    :param file_path: The path to the file we want to soft-lock.

    :return: The path to the lock file to create.

    >>> str(get_lock_file_path(Path('test.json')))
    '.test.json.lock'

    >>> get_lock_file_path(Path('C:/asdf/test.json')).as_posix()
    'C:/asdf/.test.json.lock'
    """
    return file_path.with_name(f".{file_path.name}.lock")


@contextmanager
def soft_locked_file_contents(
        file_path: Path,
        lock_timeout: Union[float, int],
) -> Generator[SimpleNamespace, None, None]:
    """
    Context manager to work with soft-locked files.

    - Soft-lock the file.
    - Yield a namespace with a 'value' attribute, allowing you to view and optionally update the contents.
    - Write the contents back to the file if modified.
    - Release the lock.

    :param file_path: The path to the file to lock / read / write / release.
    :param lock_timeout: The maximum number of seconds to wait to acquire the lock.
    """
    file_path = file_path.resolve()

    with SoftFileLock(
            lock_file=str(get_lock_file_path(file_path)),
            timeout=lock_timeout,
    ):
        original_contents = None
        if file_path.exists():
            with file_path.open('r') as f:
                original_contents = f.read()

        # Use a namespace to allow the code in the `with` block to modify the value.
        a = SimpleNamespace(value=original_contents)
        try:
            yield a
        finally:
            new_contents = a.value
            if new_contents != original_contents:
                # Update the file before releasing the lock.
                with file_path.open('w') as f:
                    f.write(new_contents)
