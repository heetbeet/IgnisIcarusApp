from contextlib import suppress
from dataclasses import dataclass
from typing import List, Dict

import numpy as np
from ordered_set import OrderedSet


def argmax_right(x):
    """
    >>> argmax_right([0, 1, 2, 3, 3, 2])
    4
    """
    length = len(x)
    i = np.argmax(x[::-1])
    return (length - 1) - i


@dataclass
class ColumnView:
    """
    >>> v = ColumnView(list("ABcDEF"))
    >>> v.columns
    ['A', 'B', 'c', 'D', 'E', 'F']
    >>> v.lowered
    ['a', 'b', 'c', 'd', 'e', 'f']
    >>> v.set
    OrderedSet(['a', 'b', 'c', 'd', 'e', 'f'])
    >>> v.map
    {'a': 'A', 'b': 'B', 'c': 'c', 'd': 'D', 'e': 'E', 'f': 'F'}

    >>> ColumnView(list("ABcCDEF"))
    Traceback (most recent call last):
    ...
    ValueError: All columns must be unique in order to arrange them.
    """
    columns: List[str]
    lowered: List[str] = None
    set: OrderedSet = None
    map: Dict[str, str] = None

    def __post_init__(self):
        self.lowered = [i.lower() for i in self.columns]
        self.set = OrderedSet(self.lowered)
        if len(self.set) != len(self.columns):
            raise ValueError("All columns must be unique in order to arrange them.")

        self.map = {j: i for i, j in zip(self.columns, self.lowered)}


@dataclass(init=False)
class ColumnComparison:
    """
    >>> ColumnComparison(ColumnView(list('ABQFG')), ColumnView(list('ABCDEF')), 'd') #doctest: +ELLIPSIS
    ColumnComparison(column_name='d',\
... lhs_map={0: 'a', 1: 'b'},\
... rhs_map={3: 'f'},\
... lhs_insert=2,\
... rhs_insert=3,\
... weight=3)

    >>> ColumnComparison(ColumnView(list('ABQFG')), ColumnView(list('ABCDEF')), 'e') #doctest: +ELLIPSIS
    ColumnComparison(column_name='e',\
... lhs_map={0: 'a', 1: 'b'},\
... rhs_map={3: 'f'},\
... lhs_insert=2,\
... rhs_insert=3,\
... weight=3)

    """
    column_name: str
    lhs_map: Dict[int, str]
    rhs_map: Dict[int, str]
    lhs_insert: int
    rhs_insert: int
    weight: int

    def __init__(
            self,
            new: ColumnView,
            old: ColumnView,
            column_name: str,
            penalty: int = None
    ):
        if penalty is None:
            penalty = min(-len(new.set), -len(old.set))

        column_name = column_name.lower()
        self.column_name = column_name
        idx = old.set.index(column_name)

        self.lhs_map = {new.set.index(i): i for i in old.set[:idx].intersection(new.set)}
        self.rhs_map = {new.set.index(i): i for i in old.set[idx + 1:].intersection(new.set)}

        self.lhs_insert = 0 if not self.lhs_map else max(self.lhs_map) + 1
        self.rhs_insert = len(new.set) if not self.rhs_map else min(self.rhs_map)

        # Give penalty if any lhs index > any rhs index
        out_of_sequence = (self.lhs_insert >= self.rhs_insert)
        lw = len(self.lhs_map)
        rw = len(self.rhs_map)

        self.weight = out_of_sequence * penalty + (lw if lw else penalty) + (rw if rw else penalty)

    def get_insert_index(self, alignment='left'):
        """
        Insert 'E' (from old column) list before 'F' at index 3
        >>> ColumnComparison(ColumnView(list('ABQFG')), ColumnView(list('ABCDEF')), 'E').get_insert_index()
        3

        Insert 'E' (from old column list) at the end of new list (since new is left aligned)
        >>> ColumnComparison(ColumnView(list('ABQFG')), ColumnView(list('WERT')), 'E').get_insert_index()
        5

        Insert 'E' (from old column list) at the beginning of new list (since new is right aligned)
        >>> ColumnComparison(
        ...     ColumnView(list('ABQFG')),
        ...     ColumnView(list('WERT')),
        ...     'E'
        ... ).get_insert_index(alignment='right')
        0
        """

        if alignment == 'right':
            insert_idx = self.lhs_insert
            if self.rhs_map and not self.lhs_map:
                insert_idx = self.rhs_insert
        elif alignment == 'left':
            insert_idx = self.rhs_insert
            if self.lhs_map and not self.rhs_map:
                insert_idx = self.lhs_insert
        else:
            raise ValueError("Alignment must be either of 'left' or 'right'")

        return insert_idx


def column_order_for_combining_headers(
        new_sequence: List[str],
        old_sequence: List[str],
        alignment='left'
) -> List[str]:
    """
    Given two sequences new=[ABCEFG] and an old=[ADCF], this heuristic will try to merge the two sequences in a order
    respecting manner, like [ABDCEFG]. The union of old and new is {ABCDEFG} with {D} only in old and {BEG} only in new,
    and will build a new sequence by taking new and weaving in values only found in old to create the final sequence.

    :param old_sequence: The old column names and order.
    :param new_sequence: The new column names and order.
    :param alignment: for the default alignment='left', the focus is let new dominate to the left, i.e. the elements
        that needs to be weaved in will be weaved in more to the right. This is why D was put after A and not after
        B in the example above. Note that the inverse applies for alignment='right'.

    >>> column_order_for_combining_headers(list('ABCEFG'), list('ADCF'))
    ['A', 'B', 'D', 'C', 'E', 'F', 'G']

    >>> column_order_for_combining_headers(list('ABQFG'), list('ABCDEF'))
    ['A', 'B', 'Q', 'C', 'D', 'E', 'F', 'G']

    >>> column_order_for_combining_headers(list('ABQFG'), list('ABCDEF'), alignment='right')
    ['A', 'B', 'C', 'D', 'E', 'Q', 'F', 'G']

    >>> column_order_for_combining_headers(list('ABCDEF'), list('ABQFG'))
    ['A', 'B', 'C', 'D', 'E', 'Q', 'F', 'G']

    >>> column_order_for_combining_headers(list('ABDEF'), list('ADCBEF'))
    ['A', 'C', 'B', 'D', 'E', 'F']

    >>> column_order_for_combining_headers(list('ABDEF'), list('ADCBEF'), alignment='right')
    ['A', 'B', 'D', 'C', 'E', 'F']

    >>> column_order_for_combining_headers(list('ADCBEF'), list('ABDEF'))
    ['A', 'D', 'C', 'B', 'E', 'F']

    >>> column_order_for_combining_headers(list('DHKGFJ'), list('SFRGJYKD'), alignment='right')
    ['S', 'D', 'H', 'K', 'G', 'F', 'R', 'J', 'Y']

    """
    # Lets keep things left-align in case we can't figure out the order
    if alignment not in ('left', 'right'):
        raise ValueError("Alignment must be either of 'left' or 'right'")

    new_sequence_mutable = list(new_sequence)

    old = ColumnView(old_sequence)
    while True:
        new = ColumnView(new_sequence_mutable)

        old_columns = old.set.difference(new.set)
        if not old_columns:
            break

        col_comparisons = {i: ColumnComparison(new, old, i) for i in old_columns}

        argmax = np.argmax if alignment == 'right' else argmax_right
        max_index = argmax([i.weight for i in col_comparisons.values()])

        max_comparison = col_comparisons[list(col_comparisons)[int(max_index)]]

        # get the real name of the column
        if max_comparison.column_name in new.map:
            column_name = new.map[max_comparison.column_name]
        else:
            column_name = old.map[max_comparison.column_name]

        new_sequence_mutable.insert(max_comparison.get_insert_index(alignment=alignment),
                                    column_name)

    return new_sequence_mutable


def column_order_for_combining_headers_with_old_header_order_preference(
        new_sequence: List[str],
        old_sequence: List[str],
        alignment='left'
) -> List[str]:
    """
    This function is the same as column_order_for_combining_headers, but given two sequences new=[ABCEFG] and
    old=[ADCF], this heuristic will rather merge these two sequences with the a preference for the old sequence.
    I.e. items from new will be weaved into the old sequence to produce the final sequence.

    :param old_sequence: The old column names and order.
    :param new_sequence: The new column names and order.
    :param alignment: See :func:`column_order_for_combining_headers`.

    >>> column_order_for_combining_headers_with_old_header_order_preference(list('ABCEFG'), list('ADCF'))
    ['A', 'B', 'D', 'C', 'E', 'F', 'G']

    >>> column_order_for_combining_headers_with_old_header_order_preference(
    ...     list('ABCEFG'),
    ...     list('ADCF'),
    ...     alignment='right'
    ... )
    ['A', 'D', 'B', 'C', 'E', 'F', 'G']

    >>> column_order_for_combining_headers_with_old_header_order_preference(list('ABDEF'), list('ADCBEF'))
    ['A', 'D', 'C', 'B', 'E', 'F']

    H is put at the end, after D
    >>> column_order_for_combining_headers_with_old_header_order_preference(list('DHKGFJ'), list('SFRGJYKD'))
    ['S', 'F', 'R', 'G', 'J', 'Y', 'K', 'D', 'H']

    H is put before F, since the rhs from H is {KGFJ} and the best thing to do wat to put it left from it's closest
    neighbour. It might have been better to put it before K, but that is a heuristic for another day.
    >>> column_order_for_combining_headers_with_old_header_order_preference(
    ...     list('DHKGFJ'),
    ...     list('SFRGJYKD'),
    ...     alignment='right',
    ... )
    ['S', 'H', 'F', 'R', 'G', 'J', 'Y', 'K', 'D']
    """
    # Swap everything around
    final_sequence = column_order_for_combining_headers(
        old_sequence,
        new_sequence,
        {'left': 'right', 'right': 'left'}[alignment],
    )

    # The case preference is of the new sequence. I.e if 'foo' is in new and 'Foo' is in old, the resulting case will be
    # 'foo'. This might, or might not be the desirable outcome.
    new_sequence_casing = {i.lower(): i for i in new_sequence}
    for i, s in enumerate(final_sequence):
        with suppress(KeyError):
            final_sequence[i] = new_sequence_casing[s.lower()]

    return final_sequence
