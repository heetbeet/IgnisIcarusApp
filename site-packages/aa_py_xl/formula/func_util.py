"""
Code related to Excel functions
"""
from __future__ import annotations

import inspect
from datetime import datetime, date
from pathlib import Path
from typing import Any, Callable
from warnings import warn

from locate import this_dir
from openpyxl.utils.datetime import to_excel

from aa_py_xl.context import excel
from aa_py_xl.formula.util import namespace_get
from aa_py_xl.formula.xl_function_validators import get_xl_function_validators
from aa_py_xl.formula.xl_functions import get_xl_functions

vba_helper_book_path = Path(this_dir(), 'helpers.xlsm').resolve()


def call_vba_function(name: str, *args) -> Any:
    """
    Call a function using the VBA helpers workbook.

    This is a fallback for when we need an excel function that has not been implemented in Python yet.
    """
    with excel(
            path=vba_helper_book_path,
            quiet=True,
            close=True,
            kill=True,
            must_exist=True,
            read_only=True,
    ) as vba_helper_book:
        warn(
            message=f"TODO: Implement VBA function '{name}' in Python for better performance.",
            stacklevel=2,
        )
        macro = vba_helper_book.macro('xlFunction_wrapper')
        return check_xl_error_return_value(
            macro(
                name,
                len(args),
                *mangle_datetime_args(args)
            )
        )


def check_xl_error_return_value(val: Any) -> Any:
    """
    Check a return value from Excel (or from a function that tries to mimic Excel) for a string error code. Instead of
    returning that string, raise an explicit Exception, so that we can do proper Pythonic error handling.

    :param val: The return value from any Excel or Excel-like function.

    :return: The same value, if we did not raise an Exception.

    >>> check_xl_error_return_value('#DIV/0!')
    Traceback (most recent call last):
    ...
    ZeroDivisionError: #DIV/0!

    >>> check_xl_error_return_value('#ERROR: foo')
    Traceback (most recent call last):
    ...
    RuntimeError: #ERROR: foo
    """
    error_map = {
        # TODO: Check if this is the most appropriate mapping of Excel errors to Python Exceptions.
        "#NULL!": ValueError,
        "#DIV/0!": ZeroDivisionError,
        "#VALUE!": ValueError,
        "#REF!": ValueError,
        "#NAME?": NameError,
        "#NUM!": ValueError,
        "#N/A": ValueError,
        "#GETTING_DATA": RuntimeError,
    }

    if not isinstance(val, str):
        return val

    if val in error_map:
        raise error_map[val](val)

    if val.startswith('#ERROR'):
        raise RuntimeError(val)

    return val


def mangle_datetime_args(args: tuple):
    return tuple(mangle_datetime_arg(a) for a in args)


def mangle_datetime_arg(arg: Any) -> Any:
    if isinstance(arg, datetime):
        return float(to_excel(arg))
    if isinstance(arg, date):
        return int(to_excel(arg))
    return arg


def find_function(
        name: str,
        namespace: Any
) -> Callable:
    """
    Find a function by name and return it.

    :param name: The name of the function to find.
    :param namespace: An additional namespace in which to try to find the function.
        This is also the namespace with which the function's arguments are evaluated.

    :return: A function.
    """
    # Look for f in the user-provided namespace.
    if namespace is not None:
        try:
            return namespace_get(namespace, name)
        except KeyError:
            pass

    # Look for f in our own excel functions.
    try:
        return get_xl_functions()[name]
    except KeyError:
        pass

    # As a last resort, create a wrapper function that calls f through VBA.
    return lambda *args: call_vba_function(name, *args)


def find_validator(
        name: str,
) -> Callable:
    """
    Find a function validator by name and return it.

    :param name: The name of the function whose validator to find.

    :return: A function that takes a single argument: A list of :class:`FormulaNode` objects representing the function
        arguments.

    >>> from aa_py_xl.formula.operands import Number
    >>> find_validator('gobbledegook')([Number('1')])

    >>> find_validator('test')([])

    >>> find_validator('test')([Number('1')])
    Traceback (most recent call last):
    ...
    ValueError: Function 'test' takes no arguments.
    """
    try:
        return get_xl_function_validators()[name]
    except KeyError:
        pass

    # We do not have a validator for this function. Return a dummy validator that will always pass.
    return lambda x: None


def is_aware(f: Callable) -> bool:
    """
    Some custom functions are aware of the fact that they are being used inside formulas, and want to access metadata
    such as the Function node and the namespace. To see if the function is 'aware', check if it has an `aa_meta`
    keyword-only argument.

    >>> is_aware(sum)
    False

    >>> def bar(aa_meta):
    ...     pass
    >>> is_aware(bar)
    False

    >>> def foo(*, aa_meta):
    ...     pass
    >>> is_aware(foo)
    True

    >>> def baz(a, *, aa_meta):
    ...     pass
    >>> is_aware(baz)
    True
    """
    try:
        p = inspect.signature(f).parameters['aa_meta']
        return p.kind == p.KEYWORD_ONLY
    except (KeyError, ValueError):
        # KeyError when aa_meta argument does not exist.
        # ValueError when function has no signature (e.g. with Python builtins).
        return False
