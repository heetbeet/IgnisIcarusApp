from __future__ import annotations

import copy
import types
from dataclasses import dataclass, field
from datetime import date
from typing import List, Generator, Optional, Any, Dict, Tuple, Union, Callable

from aa_py_xl.formula.util import quack_numeric, quack_date


@dataclass
class FormulaNode:
    """
    Represents an AST for any Excel formula, or part of it.
    """
    text: str
    parent: Optional[FormulaNode] = None
    children: List[FormulaNode] = field(default_factory=list)

    def __eq__(self, o: Any) -> bool:
        if not isinstance(o, self.__class__):
            return False

        return self.rendered == o.rendered

    @staticmethod
    def from_formula(s: str) -> FormulaNode:
        """
        Factory function to generate a node from a formula string.
        """
        from aa_py_xl.formula import parser
        return parser.formula_to_ast(s)

    @staticmethod
    def from_value(x) -> FormulaNode:
        """
        Factory function to generate a node from a value.
        """
        if x is None:
            from aa_py_xl.formula.operands import EmptyNode
            return EmptyNode()

        # Perform duck typing.
        x = quack_date(quack_numeric(x))

        if isinstance(x, str):
            from aa_py_xl.formula.operands import String
            return String(text='"' + x.replace('"', '""') + '"')

        if isinstance(x, (int, float)):
            from aa_py_xl.formula.operands import Number
            return Number(text=str(x))

        if isinstance(x, bool):
            if x:
                from aa_py_xl.formula.operands import TrueBoolean
                return TrueBoolean()
            else:
                from aa_py_xl.formula.operands import FalseBoolean
                return FalseBoolean()

        if isinstance(x, date):
            return FormulaNode.from_formula(f"DATE({x.year},{x.month},{x.day})")

        from aa_py_xl.formula.operands import PythonValue
        return PythonValue(value=x)

    @property
    def root(self) -> FormulaNode:
        """
        The origin/root node in this tree. Cheap to calculate.
        """
        return self if self.parent is None else self.parent.root

    @property
    def integrity(self) -> bool:
        """
        Test is this node is listed as it's parent's child, and also test this for the whole progeny.
        """
        keep = types.SimpleNamespace(child_parent_linked=True)

        def node_next(node):
            if node.parent:
                if len([True for c in node.parent.children if c is node]) != 1:
                    keep.child_parent_linked = False
            for c in node.children:
                node_next(c)

        node_next(self)
        return keep.child_parent_linked

    def copy_branch(self) -> FormulaNode:
        """
        Return a deep-copy of the current node, with children, but without ancestors.
        The resulting node will be the root of a new tree.

        To include ancestors, use `copy`.
        """
        node = copy.copy(self)
        node.parent = None

        def replace_children_with_copies(n):
            if n.children:
                children_old = n.children
                n.children = []
                for c in children_old:
                    c_copy = copy.copy(c)
                    n.add_child(c_copy)
                    replace_children_with_copies(c_copy)

        # Iterate from the top and work way down
        replace_children_with_copies(node)
        return node

    def copy(self) -> FormulaNode:
        """
        Deep-copy the entire tree from its root, and return this node's corresponding node on the new tree.

        This is excessive and likely not what you want, see :func:`~FormulaNode.copy_branch` for a shallower copy.
        """
        keep = types.SimpleNamespace()

        def copy_node(node):
            node_copy = copy.copy(node)
            if node is self:
                keep.node = node_copy
            return node_copy

        def replace_children_with_copies(node):
            if node.children:
                children_old = node.children
                node.children = []
                for c in children_old:
                    c_copy = copy_node(c)
                    node.add_child(c_copy)
                    replace_children_with_copies(c_copy)

        # Iterate from the top and work way down
        root_copy = copy_node(self.root)
        replace_children_with_copies(root_copy)
        return keep.node

    def replace_with(self, new_node: FormulaNode) -> None:
        """
        Replace this node with another node, and update all references. This node is not modified.
        """
        if self.parent is None:
            new_node.parent = None
        else:
            self.parent.replace_child(self, new_node)

        for c in self.children:
            c.parent = new_node

    def ascii(self) -> str:
        """
        Return a ascii tree of the node and its entire progeny.

        >>> print(FormulaNode.from_formula('2*3+5/2-5*3*3').ascii())
        (-)
         |
         +- (+)
         |   |
         |   +- (*)
         |   |   |
         |   |   +- 2
         |   |   |
         |   |   +- 3
         |   |
         |   +- (/)
         |       |
         |       +- 5
         |       |
         |       +- 2
         |
         +- (*)
             |
             +- (*)
             |   |
             |   +- 5
             |   |
             |   +- 3
             |
             +- 3

        >>> print(FormulaNode.from_formula('-(1-2)').ascii())
        (-)
         |
         +- (-)
             |
             +- 1
             |
             +- 2

        """

        def t_next(t_current, path=None):
            if path is None:
                path = []

            yield path, t_current

            for i, c in enumerate(t_current.children):
                suppress_branch = i != len(t_current.children) - 1
                yield from t_next(c, path + [suppress_branch])

        lines = []
        for ii, (block, t) in enumerate(t_next(self)):
            if hasattr(t, 'value'):
                pretty_t = str(t.value)
            else:
                pretty_t = t.text

            if not t.is_leaf():
                pretty_t = f"({t.text})"
            if ii == 0:
                lines.append(pretty_t)
            else:
                line1 = ''.join(
                    [" |" if idx == len(block) - 1 else " |  " if i else "    " for idx, i in enumerate(block)])
                line2 = ''.join([" +- " if idx == len(block) - 1 else " |  " if i else "    " for idx, i in
                                 enumerate(block)]) + pretty_t

                lines.append(line1)
                lines.append(line2)

        return '\n'.join(lines)

    def traverse_pre_order(self) -> Generator[FormulaNode]:
        """
        Depth-first pre-order tree traversal.
        See https://en.wikipedia.org/wiki/Tree_traversal
        """
        yield self
        for c in self.children:
            yield from c.traverse_pre_order()

    def traverse_post_order(self) -> Generator[FormulaNode]:
        """
        Depth-first post-order tree traversal.
        See https://en.wikipedia.org/wiki/Tree_traversal
        """
        for c in self.children:
            yield from c.traverse_post_order()
        yield self

    def trace(self) -> Generator[List[FormulaNode], None, None]:
        """
        This method is similar to :func:`~FormulaNode.walk`, but it returns a list of all the parent nodes with each
        iteration.
        """

        def t_next(t, path=None) -> Generator[List[FormulaNode], None, None]:
            if path is None:
                path = []
            path = path + [t]
            yield path

            for i, c in enumerate(t.children):
                yield from t_next(c, path)

        yield from t_next(self)

    def is_leaf(self):
        return len(self.children) == 0

    @property
    def outer_leaf(self) -> FormulaNode:
        """
        Find the leaf at the end of the longest branch in a tree.

        This is quite expensive to calculate for trees with many branches.
        """
        sz = 0
        longest = []
        for line in self.trace():
            if len(line) > sz:
                longest = line
                sz = len(longest)
        return longest[-1]

    @property
    def rendered(self) -> str:
        """
        A re-constructed formula that represents this node, parsable by Excel.
        """
        raise NotImplementedError(f"Don't know how to write formula for '{self.name}'.")

    def add_child(self, t: FormulaNode) -> None:
        """
        Add a child to the current children and link up properly.

        >>> node = FormulaNode.from_formula('A(1*2,3*4)')
        >>> node.add_child(FormulaNode.from_formula('10+20'))
        >>> node.rendered
        'A(1*2,3*4,10+20)'
        >>> node.children[-1].children[-1].root.rendered
        'A(1*2,3*4,10+20)'
        """
        t.parent = self
        self.children.append(t)

    def replace_child(self, old_node: FormulaNode, new_node: FormulaNode) -> None:
        """
        Replace a child with another child. Update the new child's parent.
        """
        i = self.children.index(old_node)
        new_node.parent = self
        self.children[i] = new_node

    @property
    def name(self):
        return type(self).__name__

    def eval(self, namespace=None) -> Any:
        """
        Resolve this node and all of its children to a single value.
        """
        raise NotImplementedError(f"Don't know how to evaluate: {repr(self)}")

    def safe_macro_eval(self, namespace=None) -> Any:
        """
        Evaluate simple nodes within macros safely.

        It's a bad idea to call :func:`FormulaNode.eval` before we have resolved all macros.
        But in order to resolve macros, we sometimes need to eval some things which we expect to be simple values.

        Nodes that cannot be evaluated safely within a macro should raise a :class:`NotImplementedError` in their
        implementation of this method.
        """
        raise NotImplementedError(f"Don't know how to evaluate: {repr(self)}")

    def validate(self, namespace=None) -> None:
        """
        Check if this part of the tree is a valid formula. Use this to quickly catch some errors before full evaluation.

        If this does not raise an error, the formula is considered valid.
        """
        raise NotImplementedError(f"Don't know how to validate: {repr(self)}")

    def resolve_macros(
            self,
            function_macros: Dict[str, Union[MacroResolverCallback, FormulaNode]] = None,
            variable_macros: Dict[str, Union[MacroResolverCallback, FormulaNode]] = None,
            predicate_macros: Dict[MacroResolverPredicate, Union[MacroResolverCallback, FormulaNode]] = None,
            max_runs: int = 10,
    ) -> FormulaNode:
        """
        Return a copy of this branch (i.e. this node and its children), where all macros are replaced with something
        equivalent, as defined in the given `*_macros` dictionaries.

        This is done recursively until no more macros are found. An error is thrown is the maximum number of runs is
        reached.

        For the *_macros dict params, each dict value is a literal :class:`FormulaNode` object that will replace the
        macro as is, OR a Python function that takes a :class:`FormulaNode` node as argument, and returns any new,
        equivalent :class:`FormulaNode` replacement object.

        :param function_macros: A dictionary (optionally case-insensitive), keyed by function name. This defines which
            :class:`Function` nodes are treated as macros, and therefore replaced.

        :param variable_macros: A dictionary (optionally case-insensitive), keyed by variable name. This defines which
            :class:`Variable` nodes are treated as macros, and therefore replaced.

        :param predicate_macros: A dictionary, keyed by predicate function. The predicate is called with the formula
            node to decide whether a macro should be applied.

        :param max_runs: The maximum number of times to traverse the tree looking for macros before giving up.

        :return: A new formula tree.
        """
        if function_macros is None:
            function_macros = {}
        if variable_macros is None:
            variable_macros = {}
        if predicate_macros is None:
            predicate_macros = {}

        # Convert function macros and variable macros into predicate macros.
        macros = {
            **{
                create_function_predicate(name): macro
                for name, macro in function_macros.items()
            },
            **{
                create_variable_predicate(name): macro
                for name, macro in variable_macros.items()
            },
            **predicate_macros,
        }

        n_runs = 0
        tree = self

        while True:
            n_resolved, tree = tree._resolve_macros(macros)
            n_runs += 1

            if n_resolved == 0:
                # No macros left. We are done.
                return tree

            if n_runs > max_runs:
                raise RuntimeError(f"Maximum macro resolution depth of {max_runs} reached.")

    def _resolve_macros(
            self,
            macros: Dict[MacroResolverPredicate, Union[MacroResolverCallback, FormulaNode]],
    ) -> Tuple[int, FormulaNode]:
        """
        Helper function for :func:`~FormulaNode.resolve_macros`. Performs a single pass of resolving macros.
        Returns the number of resolved macros along with the new AST.
        """

        new_tree = self.copy_branch()
        count = 0

        # Visit all nodes, starting at the leaves.
        for m in new_tree.traverse_post_order():

            # Run the predicates to check if this is a macro.
            for predicate, resolve in macros.items():
                if not predicate(m):
                    continue

                # We found a matching callback.
                count += 1
                if isinstance(resolve, FormulaNode):
                    # The user provided a literal replacement value.
                    resolved = resolve
                else:
                    # The user provided a callback function that returns a replacement value.
                    resolved = resolve(m)

                if m is new_tree:
                    # This is the top-level node.
                    new_tree = resolved
                else:
                    m.replace_with(resolved)

                # This node has been replaced. Do not allow multiple macros to operate on the same node.
                # Continue to the next node.
                continue

        return count, new_tree


MacroResolverCallback = Callable[[FormulaNode], FormulaNode]
"""
A callback function for the macro resolver. Returns a replacement AST node. 
"""

MacroResolverPredicate = Callable[[FormulaNode], bool]
"""
A predicate function for the macro resolver. Decides whether an AST node should be treated as a macro.
"""


def create_function_predicate(name: str) -> MacroResolverPredicate:
    """
    Create a function that checks if the given formula node is a Function with a specific name.
    """
    # Using local import to avoid circular dependency.
    from aa_py_xl.formula.operators import Function

    def p(node: FormulaNode):
        return isinstance(node, Function) and node.function_name == name.casefold()

    return p


def create_variable_predicate(name: str) -> MacroResolverPredicate:
    """
    Create a function that checks if the given formula node is a Variable with a specific name.
    """
    # Using local import to avoid circular dependency.
    from aa_py_xl.formula.operands import Variable

    def p(node: FormulaNode):
        return isinstance(node, Variable) and node.variable_name == name.casefold()

    return p
