from dataclasses import dataclass, field
from typing import Any, List, Union

from aa_py_xl.formula import util
from aa_py_xl.formula.node import FormulaNode
from aa_py_xl.formula.util import quack_numeric


@dataclass(
    eq=False,
)
class Operand(FormulaNode):
    """
    Represents a formula node that may not have any children.

    N.B.: This is not the same as a formula node that may have children but does not have children,
    e.g. a function with no arguments.
    """
    children: List[FormulaNode] = field(default_factory=list, init=False)

    @property
    def rendered(self) -> str:
        raise NotImplementedError(f"Don't know how to write formula for '{self.name}'.")

    def eval(self, namespace=None) -> Any:
        raise NotImplementedError(f"Don't know how to evaluate: {repr(self)}")

    def safe_macro_eval(self, namespace=None) -> Any:
        raise NotImplementedError(f"Don't know how to evaluate: {repr(self)}")

    def validate(self, namespace=None) -> None:
        if not self.is_leaf():
            raise ValueError(f"{self.name} is an operand and may not have children.")


@dataclass(
    eq=False,
)
class EmptyNode(Operand):
    """
    Represents an empty formula or omitted function argument.
    """
    text: str = field(default='', init=False)

    @property
    def rendered(self) -> str:
        return ''

    def eval(self, namespace=None) -> None:
        return None

    def safe_macro_eval(self, namespace=None) -> Any:
        return self.eval(namespace)

    def validate(self, namespace=None) -> None:
        super().validate(namespace)

        if len(self.text):
            raise ValueError(f"{self.name} is supposed to be an empty node.")


@dataclass(
    eq=False,
)
class Number(Operand):
    """
    Represents a number (float in Python)

    >>> a = Number('4')
    >>> a.eval()
    4
    >>> a.rendered
    '4'

    >>> a = Number('4.0')
    >>> a.eval()
    4
    >>> a.rendered
    '4'

    >>> a = Number('4.3')
    >>> a.eval()
    4.3
    >>> a.rendered
    '4.3'
    """

    @property
    def rendered(self) -> str:
        return str(self.eval())

    def eval(self, namespace=None) -> Union[float, int]:
        return quack_numeric(float(self.text))

    def safe_macro_eval(self, namespace=None) -> Any:
        return self.eval(namespace)

    def validate(self, namespace=None) -> None:
        super().validate(namespace)
        float(self.text)


@dataclass(
    eq=False,
)
class Boolean(Operand):
    """
    Represents a boolean.
    """
    text: str = field(default='', init=False)

    @property
    def rendered(self) -> str:
        if len(self.text) == 0:
            raise NotImplementedError()

        return self.text

    def eval(self, namespace=None) -> bool:
        raise NotImplementedError(f"Don't know how to evaluate: {repr(self)}")

    def safe_macro_eval(self, namespace=None) -> Any:
        return self.eval(namespace)


@dataclass(
    eq=False,
)
class TrueBoolean(Boolean):
    """
    Represents TRUE.
    """
    text: str = field(default='TRUE', init=False)

    def eval(self, namespace=None) -> bool:
        return True

    def validate(self, namespace=None) -> None:
        super().validate(namespace)
        if self.text.casefold() != 'true':
            raise ValueError(f"{self.name}.text is supposed to be 'TRUE'.")


@dataclass(
    eq=False,
)
class FalseBoolean(Boolean):
    """
    Represents FALSE.
    """
    text: str = field(default='FALSE', init=False)

    def eval(self, namespace=None) -> bool:
        return False

    def validate(self, namespace=None) -> None:
        super().validate(namespace)
        if self.text.casefold() != 'false':
            raise ValueError(f"{self.name}.text is supposed to be 'FALSE'.")


@dataclass(
    eq=False,
)
class Variable(Operand):
    """
    Represents a namespace lookup.
    """

    @property
    def variable_name(self):
        return self.text.casefold()

    @property
    def rendered(self) -> str:
        return self.text

    def eval(self, namespace=None) -> Any:
        val = util.namespace_get(namespace, self.variable_name)

        if isinstance(val, FormulaNode):
            # The variable refers to another formula, so eval recursively.
            return val.eval(namespace)

        return quack_numeric(val)

    def safe_macro_eval(self, namespace=None) -> Any:
        return self.eval(namespace)

    def validate(self, namespace=None) -> None:
        super().validate(namespace)
        util.namespace_get(namespace, self.variable_name)


@dataclass(
    eq=False,
)
class String(Operand):
    """
    Represents an Excel String.

    >>> String(text='foo').validate()
    Traceback (most recent call last):
    ...
    ValueError: String expected to be raw string nested in quotes, e.g. "hello world". Got foo

    >>> String(text='"f"oo"').validate()
    Traceback (most recent call last):
    ...
    ValueError: Quotes within String must be escaped with a double quote, e.g. "Say ""hello world""!". Got "f"oo"

    >>> String(text='"Say ""hello world""!"').eval()
    'Say "hello world"!'
    """

    @property
    def rendered(self) -> str:
        return self.text

    def eval(self, namespace=None) -> str:
        return util.de_stringify(self.text)

    def safe_macro_eval(self, namespace=None) -> Any:
        return self.eval(namespace)

    def validate(self, namespace=None) -> None:
        super().validate(namespace)

        if self.text[:1] != '"' or self.text[-1:] != '"':
            raise ValueError(f'String expected to be raw string nested in quotes, e.g. "hello world". Got {self.text}')

        if '"' in (t := self.text[1:-1]) and '"' in t.replace('""', ''):
            raise ValueError(f'Quotes within String must be escaped with a double quote, e.g. "Say ""hello world""!". '
                             f'Got {self.text}')


@dataclass(
    eq=False,
)
class PythonValue(Operand):
    """
    Represents any Python object that cannot be represented in Excel.
    """
    text: str = field(default='', init=False)
    value: Any = None

    @property
    def rendered(self) -> str:
        raise NotImplementedError(f"Type {type(self.value)} cannot be represented as an Excel formula.")

    def eval(self, namespace=None) -> Any:
        return self.value

    def safe_macro_eval(self, namespace=None) -> Any:
        return self.eval(namespace)
