from dataclasses import dataclass, field
from typing import Any, Tuple, List, Union

from aa_py_xl.formula.func_util import find_function, find_validator, is_aware
from aa_py_xl.formula.node import FormulaNode
from aa_py_xl.formula.xl_functions import concatenate


@dataclass(
    eq=False,
)
class Operator(FormulaNode):
    """
    Represents a formula node that MAY have children.

    N.B.: This does NOT mean that all nodes that subclass this MUST have children.
    """

    @property
    def rendered(self) -> str:
        raise NotImplementedError(f"Don't know how to write formula for '{self.name}'.")

    def eval(self, namespace=None) -> Any:
        raise NotImplementedError(f"Don't know how to evaluate: {repr(self)}")

    def safe_macro_eval(self, namespace=None) -> Any:
        raise NotImplementedError(f"Don't know how to evaluate: {repr(self)}")

    def validate(self, namespace=None) -> None:
        # Validate children BEFORE validating self.
        for child in self.children:
            child.validate(namespace)


@dataclass(
    eq=False,
)
class Function(Operator):
    """
    Represents a function.
    """

    @property
    def rendered(self) -> str:
        return f"{self.text}{','.join([c.rendered for c in self.children])})"

    @property
    def function_name(self):
        return self.text[:-1].casefold()

    def eval(self, namespace=None) -> Any:
        f = find_function(self.function_name, namespace)
        args = (c.eval(namespace=namespace) for c in self.children)

        # Only some functions expect the 'aa_meta' keyword argument (see the `is_aware` function). Using
        # `try` and `except TypeError` (EAFP) here would be incorrect, since the contents of `f` may also throw a
        # `TypeError`.
        if is_aware(f):
            # This function is aware of the fact that it is being used inside of the formula parser, so we can send it
            # extra metadata to allow it to access the AST and the evaluation namespace.
            return f(*args, aa_meta={
                'node': self,
                'namespace': namespace,
            })
        else:
            return f(*args)

    def safe_macro_eval(self, namespace=None) -> Any:
        raise NotImplementedError(f"The formula '{self.rendered}' is too complex to be used inside a macro.")

    def validate(self, namespace=None) -> None:
        # Validate children BEFORE validating self.
        super().validate(namespace)

        # Find and run the validator for this function.
        find_validator(self.function_name)(self.children)


@dataclass(
    eq=False,
)
class Slice(Operator):
    """
    Represents a slice, like "1:5".

    >>> from aa_py_xl.formula.operands import Number
    >>> a = Slice(children=[Number('1'), Number('3')])
    >>> a.eval()
    (1, 3)
    >>> a.start.rendered
    '1'
    >>> a.end.rendered
    '3'
    >>> a.rendered
    '1:3'
    """
    text: str = field(default=':', init=False)

    @property
    def start(self):
        return self.children[0]

    @property
    def end(self):
        return self.children[1]

    @property
    def rendered(self) -> str:
        return f'{self.start.rendered}:{self.end.rendered}'

    def eval(self, namespace=None) -> Tuple[Any, Any]:
        return self.start.eval(namespace), self.end.eval(namespace)

    def safe_macro_eval(self, namespace=None) -> Tuple[Any, Any]:
        return self.eval(namespace)


@dataclass(
    eq=False,
)
class Indexing(Operator):
    """
    Represents indexing (sometimes called subscripting in Python), like `AA[1]`.

    Use cases:

    - `table_name[column_name]` can refer to a ListObject column in Excel.
    - `var[t-1]` can refer to the value of a time-vector variable at the previous timestep in Autory formulas.
    - TODO: Structured references?
        See https://support.microsoft.com/en-us/office/using-structured-references-with-excel-tables-f5ed2452-2337-4f71-bed3-c8ae6d2b276e

    >>> from aa_py_xl.formula.operands import Number, Variable

    >>> FormulaNode.from_formula('foo[3,4:5]')  #doctest: +ELLIPSIS
    Indexing(text='[', parent=None, children=[Variable(...), Number(...), Slice(...)])

    >>> a = Indexing(children=[Variable('foo'), Number('2')])
    >>> a.rendered
    'foo[2]'

    >>> b = Indexing(children=[Variable('foo'), Number('1'), Number('5')])
    >>> b.rendered
    'foo[1,5]'

    >>> c = Indexing(children=[Variable('foo'), Slice(children=[Number('1'), Number('5')])])
    >>> c.rendered
    'foo[1:5]'
    """
    text: str = field(default='[', init=False)

    @property
    def sequence(self) -> FormulaNode:
        return self.children[0]

    @property
    def subscripts(self) -> List[FormulaNode]:
        return self.children[1:]

    @property
    def rendered(self) -> str:
        sf = self.sequence.rendered
        subscripts = ','.join([s.rendered for s in self.subscripts])

        return f'{sf}[{subscripts}]'

    def eval(self, namespace=None) -> Any:
        raise NotImplementedError(f"Don't know how to evaluate indexing: '{self.rendered}'.")

    def safe_macro_eval(self, namespace=None) -> Any:
        return self.eval(namespace)


@dataclass(
    eq=False,
)
class Sum(Operator):
    """
    Represents a summation of two or more values.
    """
    text: str = field(default='+', init=False)

    @property
    def rendered(self) -> str:
        return "+".join(f"({c.rendered})" if len(c.children) else c.rendered for c in self.children)

    def eval(self, namespace=None) -> Union[float, int]:
        return sum(c.eval(namespace=namespace) for c in self.children)

    def safe_macro_eval(self, namespace=None) -> Union[float, int]:
        return self.eval(namespace)


@dataclass(
    eq=False,
)
class Concat(Operator):
    """
    Concatenate two items into a string, like: 2 & 3 -> "23".

    >>> from aa_py_xl.formula.operands import Number, String
    >>> b = Number('2')
    >>> c = Number('3')
    >>> d = String('"foo"')
    >>> a = Concat(children=[b, c, d])
    >>> a # doctest: +ELLIPSIS
    Concat(text='&', parent=None, children=[...])
    >>> a.eval()
    '23foo'
    """
    text: str = field(default='&', init=False)

    @property
    def rendered(self) -> str:
        lhs = self.children[0]
        rhs = self.children[1]
        expr = f"{lhs.rendered}{self.text}{rhs.rendered}"

        if not lhs.children and not rhs.children:
            # No brackets required!
            return expr

        # Brackets required!
        return f"({expr})"

    def eval(self, namespace=None) -> str:
        return concatenate(*(c.eval(namespace=namespace) for c in self.children))

    def safe_macro_eval(self, namespace=None) -> Any:
        return self.eval(namespace)


@dataclass(
    eq=False,
)
class BinaryOperator(Operator):
    """
    Represents a binary operator, i.e. one that has exactly two children.
    """
    text: str = field(default='', init=False)

    @property
    def lhs(self):
        return self.children[0]

    @property
    def rhs(self):
        return self.children[1]

    @property
    def rendered(self) -> str:
        if len(self.text) == 0:
            raise NotImplementedError()

        lhs_node = self.lhs
        lhs = f"({lhs_node.rendered})" if len(lhs_node.children) else lhs_node.rendered

        rhs_node = self.rhs
        rhs = f"({rhs_node.rendered})" if len(rhs_node.children) else rhs_node.rendered

        return f"{lhs}{self.text}{rhs}"

    def eval(self, namespace=None) -> Any:
        raise NotImplementedError(f"Don't know how to evaluate: {repr(self)}")

    def safe_macro_eval(self, namespace=None) -> Any:
        return self.eval(namespace)

    def validate(self, namespace=None) -> None:
        super().validate(namespace)
        if len(self.children) != 2:
            raise ValueError(f"{self.name} is a binary operator and must have exactly two children.")


@dataclass(
    eq=False,
)
class BinaryMathOperator(BinaryOperator):
    """
    Represents a binary mathematical operator.
    """

    @staticmethod
    def calc(
            lhs: Union[float, int],
            rhs: Union[float, int],
    ) -> Union[float, int]:
        raise NotImplementedError()

    def eval(self, namespace=None) -> Union[float, int]:
        val = self.calc(
            self.lhs.eval(namespace=namespace),
            self.rhs.eval(namespace=namespace),
        )

        # Excel represents whole numbers without decimals.
        if round(val) == val:
            return int(val)
        else:
            return val


@dataclass(
    eq=False,
)
class Difference(BinaryMathOperator):
    """
    Represents the difference between two values.

    >>> from aa_py_xl.formula.operands import Number
    >>> b = Number('6')
    >>> c = Number('10')
    >>> a = Difference(children=[b, c])
    >>> a # doctest: +ELLIPSIS
    Difference(text='-', parent=None, children=[...])
    >>> a.eval()
    -4
    """
    text: str = field(default='-', init=False)

    @staticmethod
    def calc(
            lhs: Union[float, int],
            rhs: Union[float, int],
    ) -> Union[float, int]:
        return lhs - rhs


@dataclass(
    eq=False,
)
class Multiplication(BinaryMathOperator):
    """
    Represents the product of two values.

    >>> from aa_py_xl.formula.operands import Number
    >>> b = Number('6')
    >>> c = Number('4')
    >>> a = Multiplication(children=[b, c])
    >>> a # doctest: +ELLIPSIS
    Multiplication(text='*', parent=None, children=[...])
    >>> a.eval()
    24
    """
    text: str = field(default='*', init=False)

    @staticmethod
    def calc(
            lhs: Union[float, int],
            rhs: Union[float, int],
    ) -> Union[float, int]:
        return lhs * rhs


@dataclass(
    eq=False,
)
class Division(BinaryMathOperator):
    """
    Represents the quotient of two values.

    >>> from aa_py_xl.formula.operands import Number
    >>> b = Number('6')
    >>> c = Number('3')
    >>> a = Division(children=[b, c])
    >>> a # doctest: +ELLIPSIS
    Division(text='/', parent=None, children=[...])
    >>> a.eval()
    2
    """
    text: str = field(default='/', init=False)

    @staticmethod
    def calc(
            lhs: Union[float, int],
            rhs: Union[float, int],
    ) -> Union[float, int]:
        return lhs / rhs


@dataclass(
    eq=False,
)
class Exponent(BinaryMathOperator):
    """
    Represents the exponent of two values.

    >>> from aa_py_xl.formula.operands import Number
    >>> b = Number('2')
    >>> c = Number('3')
    >>> a = Exponent(children=[b, c])
    >>> a # doctest: +ELLIPSIS
    Exponent(text='^', parent=None, children=[...])
    >>> a.eval()
    8
    """
    text: str = field(default='^', init=False)

    @staticmethod
    def calc(
            lhs: Union[float, int],
            rhs: Union[float, int],
    ) -> Union[float, int]:
        return lhs ** rhs


@dataclass(
    eq=False,
)
class BinaryComparisonOperator(BinaryOperator):
    """
    Represents a binary comparison operator, which evaluates to a boolean.
    """

    @staticmethod
    def compare(
            lhs: Any,
            rhs: Any,
    ) -> bool:
        raise NotImplementedError()

    def eval(self, namespace=None) -> bool:
        return self.compare(
            self.lhs.eval(namespace=namespace),
            self.rhs.eval(namespace=namespace),
        )

    def validate(self, namespace=None) -> None:
        super().validate(namespace)
        if len(self.children) != 2:
            raise ValueError(f"{self.name} is a binary operator and must have exactly two children.")


@dataclass(
    eq=False,
)
class CompareEqual(BinaryComparisonOperator):
    """
    Represents equality comparison.
    """
    text: str = field(default='=', init=False)

    @staticmethod
    def compare(lhs: Any, rhs: Any) -> bool:
        return lhs == rhs


@dataclass(
    eq=False,
)
class CompareGreater(BinaryComparisonOperator):
    """
    Represents `lhs > rhs` comparison.
    """
    text: str = field(default='>', init=False)

    @staticmethod
    def compare(lhs: Any, rhs: Any) -> bool:
        return lhs > rhs


@dataclass(
    eq=False,
)
class CompareSmaller(BinaryComparisonOperator):
    """
    Represents `lhs < rhs` comparison.
    """
    text: str = field(default='<', init=False)

    @staticmethod
    def compare(lhs: Any, rhs: Any) -> bool:
        return lhs < rhs


@dataclass(
    eq=False,
)
class CompareGreaterEqual(BinaryComparisonOperator):
    """
    Represents `lhs >= rhs` comparison.
    """
    text: str = field(default='>=', init=False)

    @staticmethod
    def compare(lhs: Any, rhs: Any) -> bool:
        return lhs >= rhs


@dataclass(
    eq=False,
)
class CompareSmallerEqual(BinaryComparisonOperator):
    """
    Represents `lhs <= rhs` comparison.
    """
    text: str = field(default='<=', init=False)

    @staticmethod
    def compare(lhs: Any, rhs: Any) -> bool:
        return lhs <= rhs


@dataclass(
    eq=False,
)
class CompareNotEqual(BinaryComparisonOperator):
    """
    Represents `lhs != rhs` (Python) or `lhs <> rhs` (Excel) comparison.
    """
    text: str = field(default='<>', init=False)

    @staticmethod
    def compare(lhs: Any, rhs: Any) -> bool:
        return lhs != rhs


@dataclass(
    eq=False,
)
class UnaryMathOperator(Operator):
    """
    Represents a unary mathematical operator.
    """
    text: str = field(default='', init=False)

    @property
    def operand(self):
        return self.children[0]

    @staticmethod
    def calc(
            operand: Union[float, int],
    ) -> Union[float, int]:
        raise NotImplementedError()

    @property
    def rendered(self) -> str:
        if len(self.text) == 0:
            raise NotImplementedError()

        operand = self.operand
        if not len(operand.children) or isinstance(operand, Function):
            # No brackets needed.
            operand_formula = operand.rendered
        else:
            operand_formula = f"({operand.rendered})"

        return f"{self.text}{operand_formula}"

    def eval(self, namespace=None) -> Union[float, int]:
        operand = float(self.children[0].eval(namespace=namespace))

        # Excel represents whole numbers without decimals
        val = self.calc(operand)
        if round(val) == val:
            return int(val)
        else:
            return val

    def safe_macro_eval(self, namespace=None) -> Union[float, int]:
        return self.eval(namespace)

    def validate(self, namespace=None) -> None:
        super().validate(namespace)
        if len(self.children) != 1:
            raise ValueError(f"{self.name} is a unary operator and must have exactly one child.")


@dataclass(
    eq=False,
)
class Negative(UnaryMathOperator):
    """
    Represents a negative sign (negation).

    >>> from aa_py_xl.formula.operands import Number
    >>> a = Negative(children=[Number('5')])
    >>> a
    Negative(text='-', parent=None, children=[Number(text='5', parent=None, children=[])])
    >>> a.rendered
    '-5'
    >>> a.eval()
    -5
    """
    text: str = field(default='-', init=False)

    @property
    def rendered(self) -> str:
        operand = self.operand
        if isinstance(operand, Negative):
            # Two negatives cancel out, so skip them.
            return operand.operand.rendered

        return super().rendered

    @staticmethod
    def calc(operand: Union[float, int]) -> Union[float, int]:
        return -operand


@dataclass(
    eq=False,
)
class Positive(UnaryMathOperator):
    """
    Represents a positive sign (no-op).

    >>> from aa_py_xl.formula.operands import Number
    >>> a = Positive(children=[Number('5')])
    >>> a
    Positive(text='+', parent=None, children=[Number(text='5', parent=None, children=[])])
    >>> a.rendered
    '5'
    >>> a.eval()
    5
    """
    text: str = field(default='+', init=False)

    @property
    def rendered(self) -> str:
        # We never need '+5'. '5' is sufficient.
        return self.operand.rendered

    @staticmethod
    def calc(operand: Union[float, int]) -> Union[float, int]:
        return operand
