from __future__ import annotations

from dataclasses import dataclass
from functools import lru_cache
from types import SimpleNamespace as NSpace
from typing import List, Optional

import numpy as np
from parsimonious import NodeVisitor
from parsimonious.grammar import Grammar

from aa_py_xl.formula import operators, operands, config
from aa_py_xl.formula.node import FormulaNode


@dataclass
class Token:
    text: str
    token_type: str
    operator_placement: Optional[str]


class TokenVisitor(NodeVisitor):

    @staticmethod
    def visit_tokens(node, tokens: List[Token]) -> List[Token]:
        """
        Post-process the list of tokens.
        """
        # Filter tokens: Skip all whitespace tokens.
        tokens = [t for t in tokens if t.token_type != "ws"]

        for i, token in enumerate(tokens):
            if token.token_type == "operator":
                # Determine the operator placement: infix vs prefix.
                previous = tokens[i - 1]
                if token.text in '+-' and (i == 0 or previous.text[-1:] in ",([{" or previous.token_type == "operator"):
                    # This is a prefix operator, like in `+5` or `-7`.
                    token.operator_placement = "prefix"
                else:
                    token.operator_placement = "infix"
            elif token.token_type == "func":
                # Remove whitespace from function text.
                token.text = token.text.replace(" ", "").replace("\t", "")

        return tokens

    @staticmethod
    def visit_token(node, _) -> Token:
        return Token(
            text=node.text,
            token_type=node.children[0].expr_name,
            # The operator placement will be changed later.
            operator_placement=None
        )

    def generic_visit(self, node, visited_children):
        return node.text or visited_children


@lru_cache(1)
def get_grammar() -> Grammar:
    r"""
    Find the tokens for an Excel formula. This might be overkill to use a grammar module such as parsimonious to find
    only tokens, but it is fast and works well. I wanted to parse the whole string using grammar rules, but the
    recursion ended up being too difficult. I opted for pre-parsing weird excel []

    :return parsimonious Grammar object
    """

    # Regex to determine variable names
    name_re = r"[a-zA-Z_]+[a-zA-Z0-9_\.]*"

    # Regex for numeric literals
    num_re = r"([0-9]+\.[0-9]+|[0-9]+|\.[0-9]+)([Ee][+-]?[0-9]+)?"

    # ensure that longer strings are parsed first to avoid sub-match clashes
    operator_symbols = list(config.operator_precedence)
    operator_order = np.argsort([len(i) for i in operator_symbols])[::-1]
    operator_rule = " / ".join([f'"{i}"' for i in np.array(operator_symbols)[operator_order]])

    # Generate the tokenizer using grammar rules
    return Grammar(rf"""
        tokens = token*

        #Place then in order of importance...
        token = (string /
                 filereference /
                 ws /
                 number /
                 func /
                 name /
                 brackl /
                 brackr /
                 squarebrackl /
                 squarebrackr /
                 curleybrackl /
                 curleybrackr /
                 operator /
                 comma )

        string = ~r"\"(?:[^\"]*\"\")*[^\"]*\"(?!\")"
        # Don't worry about nesting, Excel does not allow [] in filenames
        # TODO: Escaping not implemented yet
        filereference = (~r"\[.*\]({name_re})?\!{name_re}" /
                         ~r"\'.*\'({name_re})?\!{name_re}")
        ws = ~r"\s+"
        number = ~r"{num_re}"
        func = (name ws? brackl)
        name = ~r"{name_re}"
        brackl = "("
        brackr = ")"
        squarebrackl = "["
        squarebrackr = "]"
        curleybrackl = "{{"
        curleybrackr = "}}"
        operator = ({operator_rule})
        comma = ","
    """)


def formula_to_tokens(s: str) -> List[Token]:
    """
    Tokenize an Excel formula.

    :param s: The formula to tokenize.
    :return: A list of tokens.
    """
    if not isinstance(s, str):
        raise TypeError(f"Formula must be a string. Got {type(s)}.")

    return TokenVisitor().visit(get_grammar().parse(s))


def formula_to_ast(s: str) -> FormulaNode:
    r"""
    Generate and abstract syntax tree from an Excel formula String

    :param s: Input excel formula string, eg. 'A+1*ABS(-3e-9)'

    :return: An Node instance representing the abstract syntax tree

    For example, the sequence for `2*3+5/2--5*3*3` is:

    .. code-block:: none

        .      *>+            />-             +==-                     *==*                        eol                           eol
        N:  2 3 |\  (2*3) 5  2 |\  (2*3) (5/2) |\  ((2*3)+(5/2)) (-5) 3 |\ ((2*3)+(5/2)) ((-5)*3) 3 |\ ((2*3)+(5/2)) (((-5)*3)*3) |\ ((2*3)+(5/2))-(((-5)*3)*3)
        O:  * + |/    +   /  - |/    +     -   |/        -        *   * |/       -          *       |/       -                    |/

    Or written as abstract syntax trees:

    .. code-block:: none

        .                                                                                                                                 -
                                                                                                                    *                          *
                                                           +                     +        *              +        *   3            +         *   3
               *>+     *        />-     *    /  +==-    *    /    -    *==*   *    /    -  3   eol    *    /    -  3     eol    *    /     -  3
        N:  2 3 |\    2 3  5  2  |\    2 3  5 2  |\    2 3  5 2   5  3  |\   2 3  5 2   5     3 |\   2 3  5 2   5         |\   2 3  5 2    5
        O:  * + |/     +   /  -  |/     +    -   |/        -      *  *  |/       -        *     |/       -                |/

    Note that ^ is right-associative and handled differently. See https://en.wikipedia.org/wiki/Operator_associativity .

    For 5^4^3^2, the following is incorrect!:

    .. code-block:: none

        .                                                    ^
                                        ^                  ^   2
               ^==^    ^      ^==^    ^   3     ^==^    ^    3
        N:  5 4 |\    5 4  3   |\    5 4     2   |\    5 4
        O:  ^ ^ |/     ^   ^   |/     ^      ^   |/     ^

    but the following greedy way is correct:

    .. code-block:: none

        .                                                ^
                                      ^                5    ^
               ^==^    ^      ^==^  5   ^       ^==^      4   ^
        N:  5 4 |\    5 4  3   |\      4 3   2   |\          3 2
        O:  ^ ^ |/     ^   ^   |/     ^      ^   |/

    and the following lazy way is also correct:

    .. code-block:: none

        .                                                     ^
                                              ^             5    ^
                    eol        ^   eol      4   ^    eof       4   ^
        N:  5 4 3 2  |\   5 4 3 2   |\   5     3 2    |\          3 2
        O:  ^ ^ ^    |/   ^ ^       |/   ^            |/
    """
    # find types and text...
    tokens = formula_to_tokens(str(s))

    # keep.i is a global placeholder unaffected by nesting
    keep = NSpace(i=0)

    def shunting_tree() -> FormulaNode:

        # The operator stack.
        opstack: List[FormulaNode] = []

        # The number stack, a.k.a. the operand stack.
        # Since operators may function as operands, this list may contain either.
        numstack: List[FormulaNode] = []

        def shunt(i: int) -> None:
            """
            Takes the operator at index i from the operator stack and applies it to the last two seen numbers on the
            number stack. The result is appended back to the number stack.

            This effectively reduces three items to a single item with children, thereby building a part of the tree.

            :param int i: The index of the operator to pop. Passed directly to the `.pop()` function.
            """
            op = opstack.pop(i)
            op.children = []

            rhs = numstack.pop()
            lhs = numstack.pop()

            op.children = [lhs, rhs]
            lhs.parent = op
            rhs.parent = op

            numstack.append(op)

        # Loop until all tokens have been processed and the operator stack is empty, at which point the number stack
        # should contain a single Node, which is the root of the final tree.
        while True:
            # If we ran out of tokens, we need to flush everything on the stacks
            flush = keep.i >= len(tokens)

            # **********************************************
            # Resolve the operator and number/operand stacks
            # **********************************************

            # Special case for prefix operators.
            if len(opstack) and len(numstack) == len(opstack) and hasattr(opstack[-1], '__prefix__'):
                # Remove our monkey-patched "__prefix__" attribute, since it has no meaning on the tree.
                delattr(opstack[-1], '__prefix__')

                # Take the last item on the number stack, make it the only child of the outer-most leaf of the prefix
                # operator, and put that operator on the number stack in the place of that child.
                operator = opstack.pop()
                operator.outer_leaf.add_child(numstack.pop())
                numstack.append(operator)

            # Normal case for infix operators.
            elif (
                    len(opstack) >= 2 and
                    len(numstack) >= 2 and
                    config.operator_precedence[opstack[-2].text] >= config.operator_precedence[opstack[-1].text] and
                    not opstack[-1].text == "^"  # ^ is right associative, this allows for that, but don't know how???
            ):
                # Combine the last two numbers with the penultimate operator.
                shunt(-2)

            # *********************************************
            # Or add more tokens to the stacks
            # *********************************************

            # Start a stack one level deeper for bracketed calculations ()
            elif not flush and tokens[keep.i].text == "(":
                # skip over `(`
                keep.i += 1

                # Everything in between the brackets becomes a single value on the number stack.
                numstack.append(shunting_tree())

                # skip over `)`
                keep.i += 1

            # Start a stack one level deeper for functions and brackets, i.e. `func(` and `{` and `[`.
            elif not flush and tokens[keep.i].text[-1:] in "({[":
                t = tokens[keep.i]
                children = []

                # Skip over `func(` or `[` or `{`.
                keep.i += 1

                # Get the first function argument. Then the rest
                children.append(shunting_tree())

                while tokens[keep.i].text == ",":
                    # Skip over comma.
                    keep.i += 1

                    # Get the next function argument.
                    children.append(shunting_tree())

                # Remove trailing empty arguments
                while children and children[-1].text == '':
                    children.pop()

                # Skip over `)` or `}` or `]`.
                keep.i += 1

                if t.text == "[":
                    # Square brackets mean: "index" or "subscript" the preceding sequence.
                    # Therefore the last item in the operand stack becomes the first child of the indexing operator.
                    # The rest of the contents of [...] are children 1 through N of the indexing operator.
                    # E.g.: `A[5,3]` becomes `[` with children `A`, `5` and `3`.
                    if not numstack:
                        raise ValueError("Cannot index nothing: expected something like A[...], got [...]")

                    sequence = numstack.pop()
                    node = operators.Indexing(
                        children=[sequence] + children,
                        # Parent will be set later, if and when this node becomes the child of another.
                    )
                    sequence.parent = node
                elif t.text == "{":
                    # ???
                    raise NotImplementedError()
                elif t.text[-1:] == "(":
                    # Function.
                    node = operators.Function(
                        text=t.text,
                        children=children,
                        # Parent will be set later, if and when this node becomes the child of another.
                    )
                else:
                    # ???
                    raise NotImplementedError()

                # Set the parent value for all of the new node's children.
                for c in node.children:
                    c.parent = node

                numstack.append(node)

            # Add prefix operators like - or + as in -1, +5 to the operator stack
            elif not flush and tokens[keep.i].operator_placement == "prefix":

                # Pop all consecutive prefix operator tokens.
                prefix_operator_tokens = []
                while tokens[keep.i].operator_placement == "prefix":
                    prefix_operator_tokens.append(tokens[keep.i])
                    keep.i += 1

                # Work from the bottom up, making the operand the child of the last prefix operator,
                # then make that the child of the penultimate prefix operator, etc.
                it = reversed(prefix_operator_tokens)
                t = next(it)
                node = operators.Positive() if t.text == '+' else operators.Negative()
                for t in it:
                    node.parent = operators.Positive(children=[node]) \
                        if t.text == '+' \
                        else operators.Negative(children=[node])
                    node = node.parent

                # Monkey patch some metadata onto the operator node for the shunting algorithm to detect later,
                # when it has to add the operand child to the leaf node.
                setattr(node, "__prefix__", True)

                opstack.append(node)

            # Otherwise add whatever token comes next to the stack
            elif not flush and tokens[keep.i].text[-1:] not in ")}],":
                t = tokens[keep.i]
                keep.i += 1

                if t.token_type == "operator":
                    opstack.append(create_operator(t))
                else:
                    numstack.append(create_operand(t))

                if len(opstack) > len(numstack):
                    raise ValueError("Too many values for too few operators")

            # Flush the left-over stack
            else:
                while len(numstack) > 1 and len(opstack):
                    # Combine the last operator with the last two numbers.
                    shunt(-1)
                break

        # At the end we should have an empty operator stack and a number stack with only one item.
        if len(opstack) or len(numstack) > 1:
            oo = "O: " + '; '.join([i.rendered for i in opstack])
            nn = "N: " + '; '.join([i.rendered for i in numstack])

            raise ValueError(f"Number of operators and numbers/operands not balanced!\n{oo}\n{nn}")

        # The one item in our number stack is the final tree.
        # If there is nothing, we have an empty tree, in which case we return a dummy root node.
        if len(numstack) == 0:
            return operands.EmptyNode()
        return numstack[0]

    return shunting_tree()


token_text_to_operator_map = {
    '+': operators.Sum,
    '-': operators.Difference,
    '*': operators.Multiplication,
    '/': operators.Division,
    '^': operators.Exponent,
    '&': operators.Concat,
    ':': operators.Slice,
    '=': operators.CompareEqual,
    '>': operators.CompareGreater,
    '<': operators.CompareSmaller,
    '>=': operators.CompareGreaterEqual,
    '<=': operators.CompareSmallerEqual,
    '<>': operators.CompareNotEqual,
}


def create_operator(token: Token):
    try:
        return token_text_to_operator_map[token.text]()
    except KeyError as e:
        raise NotImplementedError(f"Don't know what to do with operator '{token.text}'") from e


def create_operand(token: Token):
    if token.token_type == "number":
        return operands.Number(token.text)

    if token.token_type == "name":
        text_folded = token.text.casefold()

        if text_folded == 'true':
            return operands.TrueBoolean()

        if text_folded == 'false':
            return operands.FalseBoolean()

        return operands.Variable(text=token.text)

    if token.token_type == "string":
        return operands.String(text=token.text)

    raise NotImplementedError(f"Don't know what to do with operand '{token.text}'")
