from datetime import datetime, date
from typing import Any, Union, TypeVar

T = TypeVar('T')


def de_stringify(s):
    """
    Remove quotes from an excel string in order to parse it in normal Python

    >>> print(de_stringify('"hello ""1\"""'))
    hello "1"

    >>> de_stringify("hello") # doctest: +IGNORE_EXCEPTION_DETAIL
    Traceback (most recent call last):
    ValueError: Text is not quoted and cannot be de_stringified: hello

    """
    if not (s.startswith('"') and s.endswith('"')):
        raise ValueError(f"Text is not quoted and cannot be de_stringified: {s}")
    return s[1:-1].replace('""', '"')


def namespace_get(namespace: Any, key: Any) -> Any:
    """
    A wrapper function to treat a namespace similar to a dictionary.
    This allows for an agnostic namespace/dictionary approach.

    >>> import types
    >>> namespace_get(types.SimpleNamespace(a=5), 'a')
    5

    >>> namespace_get(types.SimpleNamespace(b=5), 'a')  # doctest: +IGNORE_EXCEPTION_DETAIL
    Traceback (most recent call last):
    KeyError: 'a'

    >>> namespace_get({'a':5}, 'a')
    5

    Also works with case-insensitive dictionaries.
    >>> from pydicti import dicti
    >>> namespace_get(dicti({"A": 1}), 'a')
    1

    >>> namespace_get(None, 'a')  # doctest: +IGNORE_EXCEPTION_DETAIL
    Traceback (most recent call last):
    KeyError: 'a'
    """
    try:
        return namespace[key]
    except TypeError:
        pass

    try:
        return namespace.__dict__[key]
    except AttributeError:
        pass

    raise KeyError(f"Namespace has no key '{key}'.")


def quack_numeric(val: T) -> Union[float, int, T]:
    """
    Duck-type test for number-like types.

    :param val: The value to test.
    :return: The same value, cast to float or int if possible without losing data.

    >>> quack_numeric('a')
    'a'
    >>> quack_numeric(1)
    1
    >>> quack_numeric(1.0)
    1
    >>> quack_numeric(1.1)
    1.1
    """
    try:
        (0 + (val / 1) * 1) ** 1
    except TypeError:
        # Does not quack like a number. Return as-is.
        return val
    else:
        if val == (int_val := int(val)):
            # Quacks like an integer.
            return int_val
        else:
            # Quacks like a float.
            return val


def quack_date(val: T) -> Union[datetime, date, T]:
    """
    Duck-type test for date-like types.

    :param val: The value to test.
    :return: The same value, cast to datetime or date if possible without losing data.

    >>> quack_date(date(2021, 12, 31))
    datetime.date(2021, 12, 31)
    >>> quack_date(datetime(2021, 12, 31, 12, 13, 14))
    datetime.datetime(2021, 12, 31, 12, 13, 14)
    >>> quack_date(datetime(2021, 12, 31, 0, 0, 0))
    datetime.date(2021, 12, 31)

    >>> quack_date('a')
    'a'
    >>> quack_date(1)
    1
    >>> quack_date(1.0)
    1.0
    >>> quack_date(1.1)
    1.1
    """
    if isinstance(val, datetime) and not (val.hour or val.minute or val.second):
        return val.date()

    return val
