from pathlib import Path
from typing import Union, Iterable, Optional, Dict

import xlwings as xw
from pydicti import dicti

from aa_py_xl.data_util import query_csv
from aa_py_xl.misc import sanitize_columns
from aa_py_xl.tables import LOTable, NRTable, Table, TableExistsError
from aa_py_xl.workbook_util import get_sheet, find_last_used_column


def make_unique_sheet_name(book: xw.Book, name: str) -> str:
    """
    Get a valid and unique name for a new sheet in the given workbook.

    :param book: The Excel workbook, opened by xlwings.
    :param name: The preferred sheet name.

    :return: A valid sheet name, derived from the preferred name.

    >>> from aa_py_xl.context import excel

    Long names will be truncated.
    Counters are added for duplicates.
    >>> with excel(quiet=True, kill=True) as wb:
    ...     wb.sheets.add(make_unique_sheet_name(wb, 'pneumonoultramicroscopicsilicovolcanoconiosis')).name
    ...     wb.sheets.add(make_unique_sheet_name(wb, 'pneumonoultramicroscopicsilicovolcanoconiosis')).name
    ...     wb.sheets.add(make_unique_sheet_name(wb, 'pneumonoultramicroscopicsilicovolcanoconiosis')).name
    ...     wb.sheets.add(make_unique_sheet_name(wb, 'pneumonoultramicroscopicsilicovolcanoconiosis')).name
    ...     wb.sheets.add(make_unique_sheet_name(wb, 'pneumonoultramicroscopicsilicovolcanoconiosis')).name
    ...     wb.sheets.add(make_unique_sheet_name(wb, 'pneumonoultramicroscopicsilicovolcanoconiosis')).name
    ...     wb.sheets.add(make_unique_sheet_name(wb, 'pneumonoultramicroscopicsilicovolcanoconiosis')).name
    ...     wb.sheets.add(make_unique_sheet_name(wb, 'pneumonoultramicroscopicsilicovolcanoconiosis')).name
    ...     wb.sheets.add(make_unique_sheet_name(wb, 'pneumonoultramicroscopicsilicovolcanoconiosis')).name
    ...     wb.sheets.add(make_unique_sheet_name(wb, 'pneumonoultramicroscopicsilicovolcanoconiosis')).name
    ...     wb.sheets.add(make_unique_sheet_name(wb, 'pneumonoultramicroscopicsilicovolcanoconiosis')).name
    ...     wb.sheets.add(make_unique_sheet_name(wb, 'pneumonoultramicroscopicsilicovolcanoconiosis')).name
    ...     wb.sheets.add(make_unique_sheet_name(wb, 'pneumonoultramicroscopicsilicovolcanoconiosis')).name
    ...     wb.sheets.add(make_unique_sheet_name(wb, 'foo')).name
    ...     wb.sheets.add(make_unique_sheet_name(wb, 'foo')).name
    ...     wb.sheets.add(make_unique_sheet_name(wb, 'foo')).name
    ...     wb.sheets.add(make_unique_sheet_name(wb, 'foo')).name
    ...     wb.sheets.add(make_unique_sheet_name(wb, 'foo')).name
    ...     wb.sheets.add(make_unique_sheet_name(wb, 'foo')).name
    ...     wb.sheets.add(make_unique_sheet_name(wb, 'foo')).name
    ...     wb.sheets.add(make_unique_sheet_name(wb, 'foo')).name
    ...     wb.sheets.add(make_unique_sheet_name(wb, 'foo')).name
    ...     wb.sheets.add(make_unique_sheet_name(wb, 'foo')).name
    ...     wb.sheets.add(make_unique_sheet_name(wb, 'foo')).name
    ...     wb.sheets.add(make_unique_sheet_name(wb, 'foo')).name
    ...     wb.sheets.add(make_unique_sheet_name(wb, 'foo')).name
    'pneumonoultramicroscopicsilicov'
    'pneumonoultramicroscopicsilic_0'
    'pneumonoultramicroscopicsilic_1'
    'pneumonoultramicroscopicsilic_2'
    'pneumonoultramicroscopicsilic_3'
    'pneumonoultramicroscopicsilic_4'
    'pneumonoultramicroscopicsilic_5'
    'pneumonoultramicroscopicsilic_6'
    'pneumonoultramicroscopicsilic_7'
    'pneumonoultramicroscopicsilic_8'
    'pneumonoultramicroscopicsilic_9'
    'pneumonoultramicroscopicsili_10'
    'pneumonoultramicroscopicsili_11'
    'foo'
    'foo_0'
    'foo_1'
    'foo_2'
    'foo_3'
    'foo_4'
    'foo_5'
    'foo_6'
    'foo_7'
    'foo_8'
    'foo_9'
    'foo_10'
    'foo_11'
    """
    # Get existing sheet names.
    # Abusing case-insensitive dictionary as a set.
    sheet_names = dicti({sheet.name: 1 for sheet in book.sheets})

    # Make sure the input string is no longer than the maximum sheet name length.
    max_len = 31
    name = name[:max_len]

    result = name
    i = 0
    while result in sheet_names:
        counter = str(i)
        result = f'{name[:max_len - 1 - len(counter)]}_{counter}'
        i += 1

    return result


def make_table(
        book: xw.Book,
        name: str,
        table_type: str,
        columns: Iterable[str],
        sheet_name: str,
        exist_ok: bool = True,
        row_number: int = None,
        column_number: int = None,
) -> Union[LOTable, NRTable]:
    """
    Create a new table.

    :param book: The Excel workbook, opened by xlwings.
    :param name: The name of the table to create.
    :param table_type: The type of table to create. Either 'ListObject' or 'Range'.
      Ignored if the table already exists.
    :param columns: The names of the columns to use when creating the table.
      Ignored if the table already exists.
    :param sheet_name: The name of the sheet in which to create the table.
      Ignored if the table already exists.
      Throws an error if the sheet does not exist.
    :param exist_ok: If True, don't complain if the table already exists, even if the type of the existing table is
      different from the requested type. Rather return the existing table. If False and the table already exists, raise
      a TableExistsError.
    :param row_number: The number of the first row of the new table. Auto if None. 1-indexed.
    :param column_number: The number of the first column of the new table. Auto if None. 1-indexed.

    :return: See get_table. Will either return the existing table, or the newly created one.
    """
    # Define how much space to keep between tables.
    column_margin = 3
    row_margin = 4

    try:
        table = Table.get_from_book(book, name)

        if not exist_ok:
            raise TableExistsError(f"Table '{name}' already exists as a {table.type_name}.")

        # We already have a table, and this is OK!
        return table
    except KeyError:
        # We need to create a table!
        pass

    columns = sanitize_columns(columns)
    if len(columns) < 1:
        raise ValueError("At least one column name is required when creating a table.")

    sheet = get_sheet(book, sheet_name)

    # Calculate the table position.
    if row_number is None:
        row_number = row_margin + 1
    if column_number is None:
        # Keep one empty column between the last used column and the first column of the new table.
        column_number = find_last_used_column(sheet) + column_margin + 1
    top_left = sheet.range(row_number, column_number)

    # Before writing the header, make sure the receiving cells are formatted as string.
    # See:
    # - https://github.com/xlwings/xlwings/issues/36 (open issue)
    # - https://github.com/xlwings/xlwings/issues/436 (closed issue showing workaround)
    # - https://github.com/AutoActuary/aa-py-core/issues/59 (our issue)
    header_range = top_left.resize(column_size=len(columns))
    header_range.number_format = '@'

    # Create the headers and one empty row.
    header_range.value = [columns]
    table_range = header_range.resize(row_size=2)

    if table_type == 'ListObject':
        # Create ListObject.
        # See https://docs.microsoft.com/en-us/office/vba/api/excel.listobjects.add
        lo = sheet.api.ListObjects.Add(1, table_range.api, None, 1)
        lo.Name = name

        return LOTable(
            book=book,
            sheet=sheet,
            name=name,
            lo=lo
        )

    if table_type == 'Range':
        # Create named Range.
        # If we pass rng instead of rng.api here, xlwings hangs indefinitely. This might be a bug in xlwings.
        book.names.add(name=name, refers_to=table_range.api)

        return NRTable(
            book=book,
            sheet=sheet,
            name=name,
            rng=table_range
        )

    raise NotImplementedError(f"Unknown table type '{table_type}'.")


def csv_file_to_new_table(
        book: xw.Book,
        sheet_name: str,
        table_name: str,
        row_number: Optional[int],
        column_number: Optional[int],
        input_file_path: Path,
        pandas_kwargs: Dict,
        sql_query: Optional[str],
) -> None:
    """
    Query data from a CSV file and place the results in a new ListObject in an Excel workbook.

    :param book: The Excel workbook into which to import the data.
    :param table_name: The name of the table to create or use in the workbook.
        If this table already exists, an error is thrown.
    :param sheet_name: The name of the sheet in which to create the new table.
    :param row_number: The number of the first row of the new table. Auto if None. 1-indexed.
    :param column_number: The number of the first column of the new table. Auto if None. 1-indexed.
    :param input_file_path: The path to the CSV file to import.
    :param pandas_kwargs: Extra keyword arguments to pass to the pandas.read_csv function.
    :param sql_query: An optional query to perform on the pandas DataFrame, using pandasql.
        Always use `SELECT ... FROM df ...`
    """
    df = query_csv(input_file_path, pandas_kwargs, sql_query)

    make_table(
        book=book,
        name=table_name,
        table_type="ListObject",
        columns=df.columns,
        sheet_name=sheet_name,
        exist_ok=False,
        row_number=row_number,
        column_number=column_number,
    ).from_df(df)
