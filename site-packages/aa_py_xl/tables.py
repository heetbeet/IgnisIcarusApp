"""
Classes representing tables in Excel workbooks.
Provides general extraction and manipulation functions for ListObjects and named Ranges.

These are not specific to our version control system. For VCS-specific functions, see `aa_py_xl.vcs.tables`.
"""
from __future__ import annotations

import uuid
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Union, Optional, List, Generator, Dict, Iterable, Sequence, OrderedDict

import xlwings as xw
from aa_py_core.misc import cluster_sequential
from pandas import DataFrame, Series
from pydicti import dicti

from aa_py_xl.column_order_heuristic import column_order_for_combining_headers_with_old_header_order_preference
from aa_py_xl.data_util import data_to_dicts, table_data_to_csv_file
from aa_py_xl.misc import sanitize_columns
from aa_py_xl.workbook_util import find_list_object, find_named_range


class TableExistsError(Exception):
    """
    Raised when a table already exists, and you tried to create another one by the same name.
    """
    pass


@dataclass
class Table:
    book: xw.Book = None
    sheet: xw.Sheet = None
    name: str = None

    @property
    def type_name(self):
        raise NotImplementedError()

    @staticmethod
    def get_from_book(book: xw.Book, name: str) -> Union[LOTable, NRTable]:
        """
        Get a table. Automatically detect whether the given table name refers to a ListObject or a named Range.

        A KeyError is raised when the table is not found.

        :param Book book: The Excel workbook, opened by xlwings.
        :param str name: The name of the table to retrieve.

        :return: An instance of LOTable or NRTable.
        """
        try:
            return LOTable.get_from_book(book=book, name=name)
        except KeyError:
            pass

        try:
            return NRTable.get_from_book(book=book, name=name)
        except KeyError:
            pass

        raise KeyError(f"ListObject or Range {name} was not found.")

    @staticmethod
    def exists(book: xw.Book, name: str) -> bool:
        try:
            Table.get_from_book(book, name)
            return True
        except KeyError:
            return False

    def extract_data(self, columns: Optional[List[str]] = None) -> Generator[OrderedDict, None, None]:
        """
        Extract data from the table

        :param columns: See data_to_dicts.

        :return: See data_to_dicts.
        """
        return data_to_dicts(
            data=self.range.value,
            columns=columns
        )

    def set_data(self, data: Sequence[Union[dict, Series]]) -> None:
        """
        Replace the data (rows) of a table.

        Columns that are present in the header but not in the new data will be extrapolated from the value in the first
        cell below the header in that column.

        :param data: A sequence of rows. Each row is a dict with column names as keys.
        """
        self._prepare_for_setting_data(len(data))

        # Assume that the keys of the first data element from the JSON file represents all columns.
        try:
            first_row = data[0]
        except IndexError:
            # Empty data. Nothing to set.
            return

        # Get the header and formulas from the first row.
        header = self.range.rows[0].options(ndim=1).value
        formulas = self.range.formula[1]

        for i, h in enumerate(header):
            column = self.range.columns[i][1:]
            if h in first_row:
                # Column is present in the header AND in the data. Copy the values.
                column.value = [[d.get(h)] for d in data]
            else:
                # Column is present in the header but not in the new data. Use the formula from the first row.
                # Setting a single formula for the entire column allows the relative formula magic to happen.
                column.formula = formulas[i]

    def _prepare_for_setting_data(self, data_length) -> None:
        """
        Helper function for `set_data` and `from_df`.

        :param data_length: Number of records in the data, not including the header.
        """
        # In some situations, data is not set properly if filters are applied. So clear the filters first.
        # See https://github.com/AutoActuary/aa-py-core/issues/18
        self.clear_sheet_filters()

        # The new number of rows to which to resize the table.
        # This ensures that all data is covered and there are no empty
        # rows, except when the table is empty, then keep one empty row below the header.
        n_rows_new = max(data_length + 1, 2)

        # Chop off old data from the bottom of the table if it's longer than the new data.
        self.trim_rows(data_length + 1)

        # Resize the table.
        # This needs to happen BEFORE importing new data, otherwise table formulas won't work.
        self.resize_rows(n_rows_new)

    @property
    def column_names(self) -> List[str]:
        raise NotImplementedError()

    def to_csv_file(
            self,
            include_data: bool,
            include_headers: bool,
            output_dir: Path,
            output_basename: str = None,
            columns: Optional[List[str]] = None,
    ) -> None:
        """
        Write the table contents to a CSV file.

        :param include_data: Whether to include the table data in the output.
            If this is false, the output will ONLY have a header.

        :param include_headers: Whether to include the header in the output.
            If this is false, the output will ONLY have rows.

        :param output_dir: The folder in which to place the CSV file.

        :param output_basename: The name of the output file (before the `.csv` extension).

        :param columns: A list of column names to keep when extracting table data.
            All other columns are ignored.
            If not specified, use all columns.
        """
        table_data_to_csv_file(
            data=self.extract_data(columns=columns),
            include_data=include_data,
            include_headers=include_headers,
            csv_file_path=Path(output_dir, f'{output_basename or self.name}.csv')
        )

    def from_df(self, df: DataFrame) -> None:
        """
        Replace table contents with the data from a Pandas DataFrame.

        :param df: The Dataframe to import.
        """
        # We have to set the header and the data separately, otherwise the ListObject gets destroyed.
        self.set_columns(df.columns)
        self._prepare_for_setting_data(len(df))
        self.range.offset(row_offset=1).options(index=False, header=False).value = df

    def resize_rows(self, n_rows: int) -> None:
        """
        Resize just the rows.
        """
        raise NotImplementedError()

    def resize_columns(self, n_cols: int) -> None:
        """
        Resize just the columns.
        """
        raise NotImplementedError()

    def resize(self, n_rows: int, n_cols: int) -> None:
        """
        Resize rows and columns simultaneously.
        """
        raise NotImplementedError()

    @property
    def range(self) -> xw.Range:
        raise NotImplementedError()

    def append_row(self, data: dict) -> None:
        """
        Append one row to the table.

        :param data: A dictionary of cell values.
            Keys should correspond to column names (case-insensitive).
            Missing keys will result in empty cells, not errors.
        """
        rng = self.range
        n_rows_new = rng.rows.count + 1

        # Resize the table.
        # This needs to happen BEFORE importing new data, otherwise table formulas won't work.
        self.resize_rows(n_rows_new)

        header = rng.rows[0].options(ndim=1).value
        formulas = rng.rows[1].formula[0]
        last_row = rng.resize(row_size=n_rows_new).rows[-1]
        data_ci = dicti(data)

        # Setting the cells individually is slower, but allows formulas to work robustly.
        for i, h in enumerate(header):
            cell = last_row[i]
            if h in data_ci:
                # Key is present in the header AND in the data. Copy the value.
                cell.value = data_ci.get(h)
            else:
                # Key is present in the header but not in the new data. Use the formula from the first row.
                cell.formula = formulas[i]

    def set_columns(self, columns: Iterable[str]) -> None:
        """
        Overwrite the table column names. The table width will be set to the new number of columns. No data is touched.
        """
        raise NotImplementedError()

    def rename_columns(self, rename_map: Dict[str, str]) -> None:
        """
        Rename columns from the table.

        Matching is case insensitive.
        Case is preserved for new column names.
        Does not complain about missing columns, since that may mean that they are already renamed.

        :param rename_map: A mapping of old column names to new column names.
        """
        raise NotImplementedError()

    def delete_columns(self, columns: Iterable[str]) -> None:
        """
        Delete columns from the table.

        Deletes the sheet column, not just the table column, to prevent the error
        "This won't work because it would move cells in a table on your worksheet."

        Matching is case insensitive.
        Does not complain about already deleted columns.

        :param columns: The column names to delete.
        """
        raise NotImplementedError()

    def add_missing_columns(self, columns: Iterable[str]) -> None:
        """
        For every column name given, add that column to the table if it does not exist yet.

        Uses a heuristic to determine where to insert columns.
        Matching is case insensitive.
        Case is preserved for new column names.
        Does not complain about columns that are already added.

        :param columns: The names of all columns that should be present.
        """
        # Get the current state.
        # Abusing case-insensitive dictionary as a set.
        existing_column_names = dicti({name: 1 for name in self.column_names})
        extended_column_names = column_order_for_combining_headers_with_old_header_order_preference(
            list(columns),
            existing_column_names
        )

        new_column_indices = [i for i, col in enumerate(extended_column_names) if col not in existing_column_names]
        insert_sequence = cluster_sequential(new_column_indices)

        if not insert_sequence:
            # Nothing to do here.
            return

        # Leave an anchor just left of the table (otherwise we might mutate our anchor)
        anchor_range = self.range.columns[0].offset(0, -1)

        # Weave the added columns between the old columns one by one
        # We can't use `table_lo.ListColumns.Add()` because that may cause the error
        # "This won't work because it would move cells in a table on your worksheet."
        for i, n_columns in insert_sequence.items():
            anchor_range.offset(0, i + 1).resize(column_size=n_columns).api.EntireColumn.Insert()

        # Update column names.
        anchor_range.offset(0, 1).resize(1, len(extended_column_names)).value = extended_column_names

        self.resize_columns(len(extended_column_names))

    def rename(self, new_name: str) -> None:
        """
        Rename this table.
        :param new_name: The new name of this table.
        """
        raise NotImplementedError()

    def delete(self) -> None:
        """
        Delete this table.

        It will clear the cells and remove the Name or ListObject, but it will not remove the cells.
        """
        raise NotImplementedError()

    def clear_sheet_filters(self):
        """
        Clear all filters from the sheet containing this table.
        """
        api = self.sheet.api

        # FilterMode and AutoFilterMode are independent. Disable both.
        # See https://docs.microsoft.com/en-us/office/vba/api/excel.worksheet.autofiltermode
        if api.FilterMode:
            api.ShowAllData()
        if api.AutoFilterMode:
            api.AutoFilter.ShowAllData()

        # Each ListObject also has its own AutoFilter.
        for lo in api.ListObjects:
            if lo.AutoFilter.FilterMode:
                lo.AutoFilter.ShowAllData()

    def trim_rows(self, n_rows):
        n_fewer_rows = len(self.range.rows) - n_rows
        if n_fewer_rows > 0:
            # Clear some rows at the end of the table before resizing.
            self.range.offset(row_offset=n_rows).resize(row_size=n_fewer_rows).clear()

    def trim_columns(self, n_cols):
        n_fewer_columns = len(self.range.columns) - n_cols
        if n_fewer_columns > 0:
            # Clear some columns at the end of the table before resizing.
            self.range.offset(column_offset=n_cols).resize(column_size=n_fewer_columns).clear()


@dataclass
class LOTable(Table):
    # A ListObject exposed via xlwings' Excel API. We don't have a proper python return type for this.
    # See https://docs.microsoft.com/en-us/office/vba/api/excel.listobject
    lo: Any = None

    @property
    def type_name(self):
        return "ListObject"

    @staticmethod
    def get_from_book(book: xw.Book, name: str) -> LOTable:
        """
        Get a ListObject Table by name from an Excel workbook.

        A KeyError is raised when the ListObject is not found.
        Name matching is case insensitive.

        :param Book book: The Excel workbook, opened by xlwings.
        :param str name: The name of the ListObject to retrieve.

        :return: An instance of LOTable.
        """
        lo, sheet = find_list_object(book=book, name=name)
        return LOTable(
            book=book,
            sheet=sheet,
            name=name,
            lo=lo
        )

    @property
    def column_names(self) -> List[str]:
        return [self.lo.ListColumns(i + 1).Name for i in range(self.lo.ListColumns.Count)]

    def resize_rows(self, n_rows: int) -> None:
        # ListObjects may not have fewer than 2 rows:
        # One for the header, and one data row (even if that row is empty, we can't delete it).
        n_rows = max(n_rows, 2)
        self.lo.Resize(self.range.resize(row_size=n_rows).api)

    def resize_columns(self, n_cols: int) -> None:
        self.lo.Resize(self.range.resize(column_size=n_cols).api)

    def resize(self, n_rows: int, n_cols: int) -> None:
        # ListObjects may not have fewer than 2 rows:
        # One for the header, and one data row (even if that row is empty, we can't delete it).
        n_rows = max(n_rows, 2)
        self.lo.Resize(self.range.resize(row_size=n_rows, column_size=n_cols).api)

    @property
    def range(self) -> xw.Range:
        return self.sheet.range(self.lo.Range.Address).options(ndim=2)

    @property
    def lo_columns(self) -> List[Any]:
        return [self.lo.ListColumns(i + 1) for i in range(self.lo.ListColumns.Count)]

    def set_columns(self, columns: Iterable[str]) -> None:
        columns = sanitize_columns(columns)
        self.trim_columns(len(columns))
        self.resize_columns(len(columns))

        # We first need to randomise the column names, otherwise renaming will fail silently if the new columns named
        # have any overlap with the old column names. This happens because we set the column names one by one, and
        # there may not be any duplicate column names in a ListObject.
        for column in self.lo_columns:
            column.Name = str(uuid.uuid4())

        for column, name in zip(self.lo_columns, columns):
            column.Name = name

    def rename_columns(self, rename_map: Dict[str, str]) -> None:
        existing_columns_by_name = dicti({c.Name: c for c in self.lo_columns})

        # Find old column names and rename them if necessary.
        for old_name, new_name in rename_map.items():
            if old_name in existing_columns_by_name:
                (existing_columns_by_name[old_name]).Name = new_name

    def delete_columns(self, columns: Iterable[str]) -> None:
        # Abusing case-insensitive dictionary as a set.
        columns_to_delete = dicti({c: 1 for c in columns})

        # Iterate over existing columns from right to left.
        # This prevents us from deleting the wrong columns.
        for column in reversed(self.lo_columns):
            if column.Name in columns_to_delete:
                column.Range.EntireColumn.Delete()

    def rename(self, new_name: str) -> None:
        self.lo.Name = new_name
        self.name = new_name

    def delete(self) -> None:
        # Calling `self.lo.Unlist()` is not necessary here.
        # Apparently, clearing the range will also delete the ListObject.
        self.range.clear()


@dataclass
class NRTable(Table):
    rng: xw.Range = None

    @property
    def type_name(self):
        return "Range"

    @staticmethod
    def get_from_book(book: xw.Book, name: str) -> NRTable:
        """
        Get a Range by name from an Excel workbook.

        A KeyError is raised when the range is not found.
        Name matching is case insensitive.
        Can get range from workbook scope or sheet scope.

        :param Book book: The Excel workbook, opened by xlwings.
        :param str name: The name of the Range to retrieve.

        :return: An instance of NRTable.
        """
        rng, sheet = find_named_range(book=book, name=name)
        return NRTable(
            book=book,
            sheet=sheet,
            name=name,
            rng=rng
        )

    @property
    def column_names(self) -> List[str]:
        return self.rng.rows[0].options(ndim=1).value

    def resize_rows(self, n_rows: int) -> None:
        new_range = self.range.resize(row_size=n_rows)
        self.rng.name.api.RefersTo = new_range.api
        self.rng = new_range

    def resize_columns(self, n_cols: int) -> None:
        new_range = self.range.resize(column_size=n_cols)
        self.rng.name.api.RefersTo = new_range.api
        self.rng = new_range

    def resize(self, n_rows: int, n_cols: int) -> None:
        new_range = self.range.resize(row_size=n_rows, column_size=n_cols)
        self.rng.name.api.RefersTo = new_range.api
        self.rng = new_range

    @property
    def range(self) -> xw.Range:
        return self.rng.options(ndim=2)

    def set_columns(self, columns: Iterable[str]) -> None:
        columns = sanitize_columns(columns)
        self.trim_columns(len(columns))
        self.resize_columns(len(columns))
        for column, name in zip(self.range.columns, columns):
            column.rows[0].value = name

    def rename_columns(self, rename_map: Dict[str, str]) -> None:
        # Get the existing columns' ranges, keyed by name.
        existing_columns_by_name = dicti({name: self.rng.columns[i] for i, name in enumerate(self.column_names)})

        # Find old column names and rename them if necessary.
        for old_name, new_name in rename_map.items():
            if old_name in existing_columns_by_name:
                existing_columns_by_name[old_name].rows[0].value = new_name

    def delete_columns(self, columns: Iterable[str]) -> None:
        # Abusing case-insensitive dictionary as a set.
        columns_to_delete = dicti({c: 1 for c in columns})

        n_cols = len(self.rng.columns)

        # Iterate over existing columns from right to left.
        # This prevents us from deleting the wrong columns.
        for column_range in reversed(self.rng.columns):
            if column_range.rows[0].value in columns_to_delete:
                # Delete this column.
                column_range.api.EntireColumn.Delete()
                n_cols -= 1

        # Resize the range to match the new, narrower table width.
        self.resize_columns(n_cols)

    def rename(self, new_name: str) -> None:
        self.range.name.name = new_name
        self.name = new_name

    def delete(self) -> None:
        self.range.clear()
        self.range.name.delete()
